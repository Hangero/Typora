# 4 策略模式

> 定义一系列算法，把它们一个个封装起来，并且使它们可互相替换(（变化）。该模式使得算法可独立于使用它的客户程序稳定)而变化（扩展，子类化)。
> 																										一《设计模式》GoF

## 动机

- 在软件构建过程中，某些对象使用的算法可能多种多样，经常改变，如果将这些算法都编码到对象中，将会使对象变得异常复杂而且有时候支持不使用的算法也是一个性能负担。
- 如何在运行时根据需要透明地更改对象的算法？将算法与对象本身解耦，从而避免上述问题？

## 样例

### 修改前

```cpp
enum TaxBase {
	CN_Tax,
	US_Tax,
	DE_Tax,
	FR_Tax       //更改
};

class SalesOrder{
    TaxBase tax;
public:
    double CalculateTax(){
        //...
        
        if (tax == CN_Tax){
            //CN***********
        }
        else if (tax == US_Tax){
            //US***********
        }
        else if (tax == DE_Tax){
            //DE***********
        }
		else if (tax == FR_Tax){  //更改，不叫复用
			//...
		}

        //....
     }
    
};
```

要有时间轴的概念。，从而考虑可能出现的问题。注意面向对象设计原则，要用扩展的方式面对未来的变化，而不是通过修改源代码进行修改。

> ### 开放封闭原则（OCP）
>
> - 对扩展开放，对更改封闭。
>
> - 类模块应该是可扩展的，但是不可修改。

- 复用，指的是二进制层面的复用，粘贴代码不叫复用
- 在之前代码后修改，往往会破坏之前的代码



### 修改后

```cpp
//税法策略
class TaxStrategy{
public:
    virtual double Calculate(const Context& context)=0;//上下文
    virtual ~TaxStrategy(){}
};


class CNTax : public TaxStrategy{
public:
    virtual double Calculate(const Context& context){
        //***********
    }
};

class USTax : public TaxStrategy{
public:
    virtual double Calculate(const Context& context){
        //***********
    }
};

class DETax : public TaxStrategy{
public:
    virtual double Calculate(const Context& context){
        //***********
    }
};



//扩展
//*********************************
class FRTax : public TaxStrategy{
public:
	virtual double Calculate(const Context& context){
		//.........
	}
};


class SalesOrder{
private:
    TaxStrategy* strategy;//多态指针，如果不放指针，则失去多态性

public:
    //工厂模式
    SalesOrder(StrategyFactory* strategyFactory){
        this->strategy = strategyFactory->NewStrategy();//没有写的函数，作用应该是创建对象返回指向这个对象的指针。
    }
    ~SalesOrder(){
        delete this->strategy;
    }

    public double CalculateTax(){
        //...
        Context context();//算法上下文参数
        
        double val = 
            strategy->Calculate(context); //多态调用
        //...
    }
    
};

```

> 定义一系列算法，把它们一个个封装起来，并且使它们可互相替换（**变化**）。该模式使得算法可独立于使用它的客户程序(**稳定**)而变化（**扩展，子类化**)。
> 																										一《设计模式》GoF

- 同时，代码也具有良好的本地性



## 结构

![请添加图片描述](https://img-blog.csdnimg.cn/a1f7df4c5364494494ed61c8b0d28f79.png)

- `Context`与`Strategy` — 稳定的共有算法(都需要计算某个项)
- `ConcreteStrategy` — 具体的算法细节(计算的方式可能不同)

```cpp
//稳定
Context Strategy
//变化
ConcreteStrategyA/B/C
```



## 要点

- `Strategy`及其子类为组件提供了一系列可重用的算法，从而可以使得类型在运行时方便地根据需要在各个算法之间进行切换。
- `Strategy`模式提供了用条件判断语句以外的另一种选择，消除条件判断语句，就是在解耦合。含有许多条件判断语句的代码通常都需要`Strategy`模式。
- 如果`Strategy`对象没有实例变量，那么各个上下文可以共享同一个`Strategy`对象，从而节省对象开销。

## 体会

- 在`if else`频繁出现**且变化**时，很可能需要`Strategy`
