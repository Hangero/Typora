# 5 观察者模式

> 定义对象间的一种**一对多**（变化）的依赖关系，以便当一个对象(Subject)的状态发生改变时，所有依赖于它的对象都得到通知并**自动更新**。
> 																					——《设计模式》GoF

## 动机

- 在软件构建过程中，我们需要为某些对象建立一种“"通知依赖关系”，一个对象（目标对象)的状态发生改变，所有的依赖对象（观察者对象）都将得到通知。如果这样的依赖关系过于紧密将使软件不能很好地抵御变化。
- 使用面向对象技术，可以将这种依赖关系弱化，并形成一种稳定的依赖关系。从而实现软件体系结构的松耦合。

## 样例

### 修改前

```cpp
class MainForm : public Form
{
	TextBox* txtFilePath;
	TextBox* txtFileNumber;
	ProgressBar* progressBar;	//需求：显示文件分割；但是显示分割进度的细节可								  能会变

public:
	void Button1_Click(){

		string filePath = txtFilePath->getText();
		int number = atoi(txtFileNumber->getText().c_str());

		FileSplitter splitter(filePath, number, progressBar);

		splitter.split();

	}
};

class FileSplitter
{
	string m_filePath;
	int m_fileNumber;
	ProgressBar* m_progressBar;

public:
	FileSplitter(const string& filePath, int fileNumber, ProgressBar* 			progressBar) :
		m_filePath(filePath), 
		m_fileNumber(fileNumber),
		m_progressBar(progressBar){

	}

	void split(){

		//1.读取大文件

		//2.分批次向小文件中写入
		for (int i = 0; i < m_fileNumber; i++){
			//...
            if(m_progressBar != nullptr){
                float progressValue = m_fileNumber;
				progressValue = (i + 1) / progressValue;//更新进度条
				m_progressBar->setValue(progressValue);
            }
			
		}

	}
};
```

违反依赖倒置原则：细节依赖抽象。不要依赖A，要依赖A的抽象类（父类）

> 指**编译时依赖**：A依赖B，指的是A编译时B需要存在

父类不一定由相关实现。



### 修改后

```cpp
class MainForm : public Form, public IProgress//C++推荐这样的多继承方式，一													个主类，其他都是接口（抽象基												  类）
{
	TextBox* txtFilePath;
	TextBox* txtFileNumber;

	ProgressBar* progressBar;

public:
	void Button1_Click(){

		string filePath = txtFilePath->getText();
		int number = atoi(txtFileNumber->getText().c_str());

		ConsoleNotifier cn;

		FileSplitter splitter(filePath, number，this);

		splitter.split();

	}

	virtual void DoProgress(float value){
		progressBar->setValue(value);
	}
};

class ConsoleNotifier : public IProgress {
public:
	virtual void DoProgress(float value){
		cout << ".";
	}
};

//接口，抽象基类
class IProgress{
public:
	virtual void DoProgress(float value)=0;
	virtual ~IProgress(){}
};


class FileSplitter
{
	string m_filePath;
	int m_fileNumber;

    //ProgressBar* progressBar;//通知控件
	List<IProgress*>  m_iprogressList; // 抽象通知机制
	
public:
	FileSplitter(const string& filePath, int fileNumber，IProgress* iprogress) :
		m_filePath(filePath), 
		m_fileNumber(fileNumber),
    	m_iprogress(iprogress){

	}


	void split(){

		//1.读取大文件

		//2.分批次向小文件中写入
		for (int i = 0; i < m_fileNumber; i++){
			//...
    			float progressValue = m_fileNumber
    			progressValue = (i + 1) / progressValue;
    			onProgress(progressValue);
			}
			
		}

	}


	void addIProgress(IProgress* iprogress){
		m_iprogressList.push_back(iprogress);
	}

	void removeIProgress(IProgress* iprogress){
		m_iprogressList.remove(iprogress);
	}


protected:
	virtual void onProgress(float value){
		if(iprogress != nullptr){
		m_iprogress->DoProgress(value); //更新进度条	
		}
	}
};
```



### 修改：支持多个通知

```cpp
class MainForm : public Form, public IProgress
{
	TextBox* txtFilePath;
	TextBox* txtFileNumber;

	ProgressBar* progressBar;

public:
	void Button1_Click(){

		string filePath = txtFilePath->getText();
		int number = atoi(txtFileNumber->getText().c_str());

		ConsoleNotifier cn;

		FileSplitter splitter(filePath, number);

		splitter.addIProgress(this); //订阅通知 ֪
		splitter.addIProgress(&cn); //֪

		splitter.split();

		splitter.removeIProgress(this);

	}

	virtual void DoProgress(float value){
		progressBar->setValue(value);
	}
};

class ConsoleNotifier : public IProgress {
public:
	virtual void DoProgress(float value){
		cout << ".";
	}
};



class IProgress{
public:
	virtual void DoProgress(float value)=0;
	virtual ~IProgress(){}
};


class FileSplitter
{
	string m_filePath;
	int m_fileNumber;

	List<IProgress*>  m_iprogressList; // 抽象通知机制，支持多个观察者
public:
	FileSplitter(const string& filePath, int fileNumber) :
		m_filePath(filePath), 
		m_fileNumber(fileNumber){

	}


	void split(){

		//1.读取大文件

		//2.分批次向小文件中写入
		for (int i = 0; i < m_fileNumber; i++){
			//...

			float progressValue = m_fileNumber;
			progressValue = (i + 1) / progressValue;
			onProgress(progressValue);//����֪ͨ
		}

	}

	//下面三个方法可以放在基类里
	void addIProgress(IProgress* iprogress){
		m_iprogressList.add(iprogress);
	}

	void removeIProgress(IProgress* iprogress){
		m_iprogressList.remove(iprogress);
	}


protected:
	virtual void onProgress(float value){
		
		List<IProgress*>::iterator itor=m_iprogressList.begin();

		while (itor != m_iprogressList.end() )
			(*itor)->DoProgress(value); //更新进度条
			itor++;
		}
	}
};
```



## 结构

![image-20230303225818136](/home/suyu/.config/Typora/typora-user-images/image-20230303225818136.png)



![image-20230303230157254](/home/suyu/.config/Typora/typora-user-images/image-20230303230157254.png)

红色部分稳定，蓝色部分变化



## 要点

- 使用面向对象的抽象，Observer模式使得我们可以独立地改变目标与观察者，从而使二者之间的依赖关系达致松耦合。
- 目标发送通知时，**无需指定观察者，通知（可以携带通知信息作为参数)会自动传播**。
- 观察者**自己决定是否需要订阅通知**，目标对象对此一无所知。
- Observert模式是基于事件的UI框架中非常常用的设计模式，也是MVC模式的一个重要组成部分。















