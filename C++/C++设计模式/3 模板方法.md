# 3 模板方法

> 定义一个操作中的算法的骨架 **(稳定)** ，而将一些步骤延迟 **(变化)** 到子类中。 Template Method使得子类可以不改变**(复用)**一个算法的结构即可重定义(override 重写)该算法的 某些特定步骤。 ——《 设计模式》 GoF

[**Template Method**](https://github.com/liu-jianhao/Cpp-Design-Patterns/tree/master/Template%20Method)

## 组件协作模式

通过晚期绑定，实现**框架与应用程序**之间的松耦合。实现「框架与应用程序之间的划分」

## 动机

软件构造过程中，对于某项任务，有**稳定**的整体操作**结构**，但各个子步骤却有很多**改变**的需求；或者由于固有原因而无法和任务整体结构同时实现。

模板方法能够在**稳定操作**的前提下，灵活应对各个**子步骤的变化**及晚期实现需求。

<img src="image/3 模板方法/ee9c4f92ca5d45349114d37aafeee837.png" alt="img" style="zoom: 50%;" />

- `AbstractClass` — 稳定的流程
- `ConcreteClass` — 实现时会变化的步骤

## 样例

```shell
├── Makefile
├── README.md
├── template1_app.cpp
├── template1_lib.cpp
├── template2_app.cpp
└── template2_lib.cpp

```

### 修改前：结构化设计流程

```cpp
#include <iostream>

using namespace std;

//程序库开发人员
class Library
{

public:
        void Step1()
        {
                cout << "Step1" << endl;
        }

        void Step3()
        {
                cout << "Step3" << endl;
        }

        void Step5()
        {
                cout << "Step5" << endl;
        }
};

#include "template1_lib.cpp"

//应用开发人员
class Application
{
  public:
	bool Step2()
	{
		cout << "myStep2" << endl;
		return true;
	}

	void Step4()
	{
		cout << "myStep4" << endl;
	}
};

//使用├── template1_app.cpp
//	 ├── template1_lib.cpp
int main()
{
	Library lib;
	Application app;

	lib.Step1();

	if (app.Step2())
	{
		lib.Step3();
	}

	for (int i = 0; i < 4; i++)
	{
		app.Step4();
	}

	lib.Step5();
}

```

<img src="/home/suyu/.config/Typora/typora-user-images/image-20230224195724401.png" alt="image-20230224195724401" style="zoom: 33%;" />



### 修改后：面向对象设计流程

```cpp
#include <iostream>

using namespace std;

//程序库开发人员
class Library
{
  public:
    //稳定 template method
    void Run()
    {
        Step1();

        if (Step2())//支持变化 ==> 虚函数多态调用
        { 
            Step3();
        }

        for (int i = 0; i < 4; i++)
        {
            Step4(); //支持变化 ==> 虚函数多态调用
        }

        Step5();
    }
    virtual ~Library() {}//基类函数写成虚函数

  protected:
    void Step1()
    { //稳定
        cout << "Step1" << endl;
    }
    void Step3()
    { //稳定
        cout << "Step3" << endl;
    }
    void Step5()
    {   //稳定
        cout << "Step5" << endl;
    }

    //
    virtual bool Step2() = 0; //变化
    virtual void Step4() = 0; //变化
};


#include "template2_lib.cpp"
#include <iostream>

using namespace std;

//应用程序开发人员
class Application : public Library
{
  protected:
	virtual bool Step2()
	{
		//... 子类重写实现
		cout << "override Step2" << endl;
		return true;
	}

	virtual void Step4()
	{
		//... 子类重写实现
		cout << "override Step4" << endl;
	}
};

int main()
{
	Library *pLib = new Application();
	pLib->Run();

	delete pLib;
}

```

<img src="/home/suyu/.config/Typora/typora-user-images/image-20230224195916545.png" alt="image-20230224195916545" style="zoom:33%;" />

### 早绑定与晚绑定

```cpp
//修改前：
Library ==> Application //早绑定，先写的程序被后写的程序调用
       (被调用)
//修改后
Library <== Application //晚绑定
       (虚函数调用)
```

> 定义一个操作中的算法的骨架 **(稳定)** ，而将一些步骤延迟 **(变化)** 到子类中。 `Template Method`使得子类可以不改变**(复用)**一个算法的结构即可重定义(override 重写)该算法的 某些特定步骤。 ——《 设计模式》 GoF

- 延迟，往往是定义一个虚函数让子类实现，满足子类变化。

- 稳定的代码写成非虚函数；支持变化的写成虚函数

## 结构

![image-20230224201852463](/home/suyu/.config/Typora/typora-user-images/image-20230224201852463.png)

```cpp
//稳定
TemplateMethod()
//变化
PrimitveOperation1()
PrimitveOperation2()
```

## 要点

- `Template Method`是非常常用的基础设计模式，面向对象系统中大量使用。
- `Template Method`机制简洁(虚函数的重载)，为许多应用程序架构提供了灵活扩展点，是代码复用层面的基本实现结构。
- `Template Method`内含反向控制结构(App调用Lib中的方法 ==> Lib调用App重写的方法)
- `Template Method`调用的虚方法可以不做实现，但一般设计为protected方法。(流程中的一部分，不供外界调用)



## 体会

- 可以是学长先把流程写好，再由其他人开发细节，方便控制流程
- 可以通过回调机制实现（Callback/函数指针）（晚绑定）
- 只见树木，不见森林















