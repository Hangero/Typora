# 7 桥模式

> 将**抽象部分（业务功能）与实现部分（平台实现）分离**，使它们
> 都可以独立地变化。
> 																	一《设计模式》GoF

## 动机

- 由于某些类型的固有的实现逻辑，使得它们具有两个变化的维度，
  乃至多个纬度的变化。
- 如何应对这种“多维度的变化”？**如何利用面向对象技术来使得类型**
  **可以轻松地沿着两个乃至多个方向变化，而不引入额外的复杂度**？

## 样例

### 修改前

```cpp
class Messager{
public:
    virtual void Login(string username, string password)=0;
    virtual void SendMessage(string message)=0;
    virtual void SendPicture(Image image)=0;

    virtual void PlaySound()=0;
    virtual void DrawShape()=0;
    virtual void WriteText()=0;
    virtual void Connect()=0;
    
    virtual ~Messager(){}
};


//平台实现

class PCMessagerBase : public Messager{
public:
    
    virtual void PlaySound(){
        //**********
    }
    virtual void DrawShape(){
        //**********
    }
    virtual void WriteText(){
        //**********
    }
    virtual void Connect(){
        //**********
    }
};

class MobileMessagerBase : public Messager{
public:
    
    virtual void PlaySound(){
        //==========
    }
    virtual void DrawShape(){
        //==========
    }
    virtual void WriteText(){
        //==========
    }
    virtual void Connect(){
        //==========
    }
};



//业务抽象

class PCMessagerLite : public PCMessagerBase {
public:
    
    virtual void Login(string username, string password){
        
        PCMessagerBase::Connect();
        //........
    }
    virtual void SendMessage(string message){
        
        PCMessagerBase::WriteText();
        //........
    }
    virtual void SendPicture(Image image){
        
        PCMessagerBase::DrawShape();
        //........
    }
};



class PCMessagerPerfect : public PCMessagerBase {
public:
    
    virtual void Login(string username, string password){
        
        PCMessagerBase::PlaySound();
        //********
        PCMessagerBase::Connect();
        //........
    }
    virtual void SendMessage(string message){
        
        PCMessagerBase::PlaySound();
        //********
        PCMessagerBase::WriteText();
        //........
    }
    virtual void SendPicture(Image image){
        
        PCMessagerBase::PlaySound();
        //********
        PCMessagerBase::DrawShape();
        //........
    }
};


class MobileMessagerLite : public MobileMessagerBase {
public:
    
    virtual void Login(string username, string password){
        
        MobileMessagerBase::Connect();
        //........
    }
    virtual void SendMessage(string message){
        
        MobileMessagerBase::WriteText();
        //........
    }
    virtual void SendPicture(Image image){
        
        MobileMessagerBase::DrawShape();
        //........
    }
};


class MobileMessagerPerfect : public MobileMessagerBase {
public:
    
    virtual void Login(string username, string password){
        
        MobileMessagerBase::PlaySound();
        //********
        MobileMessagerBase::Connect();
        //........
    }
    virtual void SendMessage(string message){
        
        MobileMessagerBase::PlaySound();
        //********
        MobileMessagerBase::WriteText();
        //........
    }
    virtual void SendPicture(Image image){
        
        MobileMessagerBase::PlaySound();
        //********
        MobileMessagerBase::DrawShape();
        //........
    }
};


void Process(){
        //编译时装配
        Messager *m =
            new MobileMessagerPerfect();
}

//类的数目：1+n+m*n
//有很多结构性的重复
```

### 修改后

有装饰模式基础时，可以使用：

- 把父类变成字段放入成员函数
- 把放入的字段修改成指针，保证多态性

```cpp
class PCMessagerLite{
    Message* messager; //再次修改，
public:
	virtual void Login(string username,string password){
	messager->Connect();
	//
    }
	virtual void SendMessage(string message){
	messager->WriteText();
    }
	virtual void SendPicture(Image image){
	messager->DrawShape();
	//
    }
}

class MobileMessagerLite{
      MobileMessagerBase *messager;
public:
	virtual void Login(string username,string password){
	messager->Connect();
	//
	}
	virtual void SendMessage(string message){
	messagerWriteText();
	//
	}
	virtual void SendPicture(Image image){
	MobileMessagerBase:DrawShape();
	//
    }
}


```

再次修改，继续抽象

```cpp
class PCMessagerLite{
    Message* messager; //再次修改，在未来，可以被实现为new PCMessagerBase
public:
	virtual void Login(string username,string password){
	messager->Connect();
	//
    }
	virtual void SendMessage(string message){
	messager->WriteText();
    }
	virtual void SendPicture(Image image){
	messager->DrawShape();
	//
    }
}

class MobileMessagerLite{
      Messager *messager;//new MobileMessagerBase();
public:
	virtual void Login(string username,string password){
	messager->Connect();
	//
	}
	virtual void SendMessage(string message){
	messagerWriteText();
	//
	}
	virtual void SendPicture(Image image){
	MobileMessagerBase:DrawShape();
	//
    }
}


```

于是发现`PCMessagerLite`，`MobileMessagerLite`此时已经没有区别。

```cpp
class MessagerLite:public Messager{
      Messager *messager;//new MobileMessagerBase();
public:
	virtual void Login(string username,string password){
		messager->Connect();
	//
	}
	virtual void SendMessage(string message){
		messager->WriteText();
	//
	}
	virtual void SendPicture(Image image){
		messager->DrawShape();
	//
    }
}


class MessagerPerfect   {
     Messager* messager;//new PCMessagerBase
public:
    
    virtual void Login(string username, string password){
        
        messager->PlaySound();
        //********
        messager->Connect();
        //........
    }
    virtual void SendMessage(string message){
        
        messager->PlaySound();
        //********
        messager->WriteText();
        //........
    }
    virtual void SendPicture(Image image){
        
        messager->PlaySound();
        //********
        messager->DrawShape();
        //........
    }
};
```

但是发现`new MobileMessagerBase()`不成立，因为是抽象基类，仅仅只实现了`Messager`中的一部分纯虚函数。于是我们发现`Messager`的设置并不合适。

```cpp
//未修改
class Messager{
public:
    virtual void Login(string username, string password)=0;
    virtual void SendMessage(string message)=0;
    virtual void SendPicture(Image image)=0;
  
    virtual void PlaySound()=0;
    virtual void DrawShape()=0;
    virtual void WriteText()=0;
    virtual void Connect()=0;
    
    virtual ~Messager(){}
};


//修改
class Messager{
public:
    virtual void Login(string username, string password)=0;
    virtual void SendMessage(string message)=0;
    virtual void SendPicture(Image image)=0;

    virtual ~Messager(){}
};

class MessagerImp{
public:
    virtual void PlaySound()=0;
    virtual void DrawShape()=0;
    virtual void WriteText()=0;
    virtual void Connect()=0;

    virtual ~Messager(){}
};

```

继续修改

```cpp
class MessagerLite:public Messager{
      MessagerImp *messagerImp;//new MobileMessagerBase();
public:
	virtual void Login(string username,string password){
		messagerImp->Connect();
	//
	}
	virtual void SendMessage(string message){
		messagerImp->WriteText();
	//
	}
	virtual void SendPicture(Image image){
		messagerImp->DrawShape();
	//
    }
}


class MessagerPerfect  :public Messager {
     MessagerImp *messagerImp;  
public:
    
    virtual void Login(string username, string password){
        
        messagerImp->PlaySound();
        //********
        messagerImp->Connect();
        //........
    }
    virtual void SendMessage(string message){
        
        messagerImp->PlaySound();
        //********
        messagerImp->WriteText();
        //........
    }
    virtual void SendPicture(Image image){
        
        messagerImp->PlaySound();
        //********
        messagerImp->DrawShape();
        //........
    }
};
```

如果同样的子类中有同样的字段，向上提，成为基类中的字段

```cpp
class Messager{
  MessagerImp *messagerImp;  
public:
    virtual void Login(string username, string password)=0;
    virtual void SendMessage(string message)=0;
    virtual void SendPicture(Image image)=0;

    virtual ~Messager(){}
};
class MessagerImp{
public:
    virtual void PlaySound()=0;
    virtual void DrawShape()=0;
    virtual void WriteText()=0;
    virtual void Connect()=0;

    virtual ~Messager(){}
};

class MessagerLite:public Messager{
public:
	virtual void Login(string username,string password){
		messagerImp->Connect();
	//
	}
	virtual void SendMessage(string message){
		messagerImp->WriteText();
	//
	}
	virtual void SendPicture(Image image){
		messagerImp->DrawShape();
	//
    }
}


class MessagerPerfect  :public Messager {
public:
    virtual void Login(string username, string password){
        
        messagerImp->PlaySound();
        //********
        messagerImp->Connect();
        //........
    }
    virtual void SendMessage(string message){
        
        messagerImp->PlaySound();
        //********
        messagerImp->WriteText();
        //........
    }
    virtual void SendPicture(Image image){
        
        messagerImp->PlaySound();
        //********
        messagerImp->DrawShape();
        //........
    }
};

void Process(){
    //运行时装配
    MessagerImp* mImp = new PCMessagerImp();//修改名字
    Messager *m = new Messager(mImp)；
}
//类的数目 1+n+m
```

## 结构

变化抽象类中有个多态指针，指向实现抽象类。抽象类都有自己的子类，独自变化。

![image-20230324235935008](/home/suyu/.config/Typora/typora-user-images/image-20230324235935008.png)

## 要点 

- Bridge模式使用“**对象间的组合关系”解耦了抽象和实现之间固有的绑定关系**，使得抽象和实现可以沿着各自的维度来变化。所谓抽象和实现沿着各自纬度的变化，即“子类化”它们。

  > 一个负责接口，一个负责处理

- Bridge模式有时候类似于多继承方案，但是多继承方案往往违背单一职责原则（即一个类只有一个变化的原因），复用性比较差。Bridge模式是比多继承方案更好的解决方法。

- Bridge:模式的应用一般在“两个非常强的变化维度”，有时一个类也有多于两个的变化维度，这时可以使用Bridge的扩展模式。

与装饰模式区别：

- 装饰器时实现与实现的组合，桥模式时抽象和实现的组合