# 状态模式

> 允许一个对象在其内部状态改变时改变它的行为。从而使对象看起来似乎修改了其行为。
> 																									——《设计模式》GoF

## 状态变化模式

在组件构建过程中，某些对象的状态经常面临变化，如何对这些变化进行有效的管理？同时又维持高层模块的稳定？“状态变化”模式为这一问题提供了一种解决方案。

> 典型模式
>
> - State
> - Memento

## 动机

- 在软件构建过程中，**某些对象的状态如果改变，其行为也会随之而发生变化**，比如文档处于只读状态，其支持的行为和读写状态支持的行为就可能完全不同。
- 如何在运行时根据对象的状态来透明地更改对象的行为？而不会为对象操作和状态转化之间引入紧耦合？ 

## 样例

### 修改前

```cpp
enum NetworkState
{
    Network_Open,
    Network_Close,
    Network_Connect,//思考，以后会不会有其他状态？之前代码如何修改？
    //Network_Wait
};

class NetworkProcessor{
    
    NetworkState state;
//违背开闭原则，需求的变更会导致方法实现的改变
public:
    
    void Operation1(){
        if (state == Network_Open){

            //**********
            state = Network_Close;
        }
        else if (state == Network_Close){

            //..........
            state = Network_Connect;
        }
        else if (state == Network_Connect){

            //$$$$$$$$$$
            state = Network_Open;
        }
    }

    public void Operation2(){

        if (state == Network_Open){
            
            //**********
            state = Network_Connect;
        }
        else if (state == Network_Close){

            //.....
            state = Network_Open;
        }
        else if (state == Network_Connect){

            //$$$$$$$$$$
            state = Network_Close;
        }
    
    }
     
    public void Operation3(){
    }
};
```



### 修改后

```cpp
class NetworkState{
//修改枚举类
//提出抽象基类
public:
    //状态对象的指针
    NetworkState* pNext;
    //把有关状态操作，变成状态对象的行为
    virtual void Operation1()=0;
    virtual void Operation2()=0;
    virtual void Operation3()=0;

    virtual ~NetworkState(){}
};


class OpenState :public NetworkState{
    
    static NetworkState* m_instance;
public:
    static NetworkState* getInstance(){
        if (m_instance == nullptr) {
            m_instance = new OpenState();
        }
        return m_instance;
    }

    void Operation1(){
        
        //**********
        //每一个操作对应的下一个状态是固定的
        //在每一个上下文情况里，操作是一样的，下一个
        pNext = CloseState::getInstance();
    }
    
    void Operation2(){
        
        //..........
        pNext = ConnectState::getInstance();
    }
    
    void Operation3(){
        
        //$$$$$$$$$$
        pNext = OpenState::getInstance();
    }
    
    
};

class CloseState:public NetworkState{ }
//...

//扩展
class WaitState:public NetworkState{}
class NetworkProcessor{
    
    NetworkState* pState;
    
public:
    
    NetworkProcessor(NetworkState* pState){
        
        this->pState = pState;
    }
    
    void Operation1(){
        //...
        pState->Operation1();//虚函数是一个运行时的if-else
        pState = pState->pNext;//永远等于下一个状态
        //...
    }
    
    void Operation2(){
        //...
        pState->Operation2();
        pState = pState->pNext;
        //...
    }
    
    void Operation3(){
        //...
        pState->Operation3();
        pState = pState->pNext;
        //...
    }

};



```

## 结构

![](/home/suyu/.config/Typora/typora-user-images/image-20230419191044406.png)

## 要点

- State模式将所有与一个特定状态相关的行为都放入一个State的子类对象中，在对象状态切换时，切换相应的对象；但同时维持State的接口，这样**实现了具体操作与状态转换之间的解耦**。
- 为不同的状态引入不同的对象使得状态转换变得更加明确，而且可以保证不会出现状态不一致的情况，因为**转换是原子性的**——即要么彻底转换过来，要么不转换。只关心后继态。
- 如果State对象没有实例变量，那么各个上下文可以共享同一个State对象，从而节省对象开销。