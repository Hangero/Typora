# 重构原则

## 何为重构

- 软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。
- 使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构

**重构的目的是使软件更容易被理解和修改。**你可以在软件内部做很多修改，但必须对软件可观察的外部行为只造成很小变化，或甚至不造成变化。与之形成对比的是性能优化。和重构一样，性能优化通常不会改变组件的行为（除了执行速度），只会改变其内部结构。但是两者出发点不同：性能优化往往使代码较难理解，但为了得到所需的性能你不得不那么做。

> 使用重构技术开发软件时，你把自己的时间分配给两种截然不同的行为：添加新功能，以及重构。**添加新功能时，你不应该修改既有代码，只管添加新功能**。通过测试（并让测试正常运行），你可以衡量自己的工作进度。**重构时你就不能再添加功能，只管改进程序结构**。此时你不应该添加任何测试（除非发现有先前遗漏的东西），只在绝对必要（用以处理接
> 口变化)时才修改测试。

## 为何重构

### 改进软件设计

重构很像是在整理代码，你所做的就是让所有东西回到应处的位置上。代码结构的流失是累积性的。愈难看出代码所代表的设计意图，就愈难保护其中设计，于是该设计就腐败得愈快。经常性的重构可以帮助代码维持自己该有的形态。

完成同样一件事，设计不良的程序往往需要更多代码，这常常是因为代码在不同的地方使用完全相同的语句做同样的事。因此改进设计的一个重要方向就是消除重复代码。

### 使软件更容易理解

所谓程序设计，很大程度上就是与计算机交谈：你编写代码告诉计算机做什么事，它的响应则是精确按照你的指示行动。你得及时填补“想要它做什么”和“告诉它做什么”之间的缝隙。这种编程模式的核心就是“准确说出我所要的”。

### 帮助找到BUG

### 提高编程速度

## 何时重构

几乎任何情况下我都反对专门拨出时间进行重构。在我看来，重构本来就不是件应该特别拨出时间做的事情，重构应该随时随地进行。你不应该为重构而重构，你之所以重构，是因为你想做别的什么事，而重构可以帮助你把那些事做好。

### 三次法则

Don Roberts给了我一条准则：第一次做某件事时只管去做；第二次做类似的事会产生反感，但无论如何还是可以去做：第三次再做类似的事，你就应该重构。

### 添加功能时重构

最常见的重构时机就是我想给软件添加新特性的时候。此时，**重构的直接原因往往是为了帮助我理解需要修改的代码**一这些代码可能是别人写的，也可能是我自己写的。无论何时，只要我想理解代码所做的事，我就会问自己：**是否能对这段代码进行重构，使我能更快地理解它**。然后我就会重构。之所以这么做，部分原因是为了让我下次再看这段代码时容易理解，但最主要的原因是：如果在前进过程中把代码结构理清，我就可以从中理解更多东西。

在这里，**重构的另一个原动力是：代码的设计无法帮助我轻松添加我所需要的特性。**我看着设计，然后对自己说：“如果用某种方式来设计，添加特性会简单得多。”这种情况下我不会因为自己过去的错误而懊恼一一我用重构来弥补它。之所以这么做，部分原因是为了让未来增加新特性时能够更轻松一些，但最主要的原因还是：我发现这是最快捷的途径。重构是一个快速流畅的过程，一旦完成重构，新特性的添加就会更快速、更流畅。

### 修补错误时重构

调试过程中运用重构，多半是为了让代码更具可读性。当我看着代码并努力理解它的时候，我用重构帮助加深自己的理解。我发现以这种程序来处理代码，常常能够帮助我找出bug。你可以这么想：如果收到一份错误报告，这就是需要重构的信号，因为显然代码还不够清晰一没有清晰到让你能一眼看出bug。

### 复审代码时重构

![image-20230527030433328](/home/suyu/.config/Typora/typora-user-images/image-20230527030433328.png)

### 间接层与重构

> “计算机科学是这样一门科学：它相信所有问题都可以通过增加一个间接层
> 来解决。”
> 																                   ——Dennis DeBruler

由于软件工程师对间接层如此醉心，你应该不会惊讶大多数重构都为程序引入了更多间接层。重构往往把大型对象拆成多个小型对象，把大型函数拆成多个小型函数。
但是，间接层是一柄双刃剑。每次把一个东西分成两份，你就需要多管理一个东西。如果某个对象委托另一对象，后者又委托另一对象，程序会愈加难以阅读。基于这个观点，你会希望尽量减少间接层。
别急，伙计！间接层有它的价值。下面就是间接层的某些价值。

- 允许逻辑共享。比如说一个子函数在两个不同的地点被调用，或超类中的
  某个函数被所有子类共享。
- 分开解释意图和实现。你可以选择每个类和函数的名字，这给了你一个解
  释自已意图的机会。类或函数内部则解释实现这个意图的做法。如果类和
  函数内部又以更小单元的意图来编写，你所写的代码就可以描述其结构中的
  大部分重要信息。
- 隔离变化。**很可能我在两个不同地点使用同一对象，其中一个地点我想改**
  **变对象行为，但如果修改了它，我就要冒同时影响两处的风险。为此我做**
  **出一个子类，并在需要修改处引用这个子类。现在，我可以修改这个子类**
  **而不必承担无意中影响另一处的风险。**
- 封装条件逻辑。对象有一种奇妙的机制：**多态消息，可以灵活而清晰地表**
  **达条件逻辑。将条件逻辑转化为消息形式，往往能降低代码的重复、增加**
  **清晰度并提高弹性。**

这就是重构游戏：***在保持系统现有行为的前提下，如何才能提高系统的质量***
***或降低其成本，从而使它更有价值***？
这个游戏中最常见的变量就是：你如何看待你自己的程序。找出一个缺乏“间
接层利益”之处，在不修改现有行为的前提下，为它加入一个间接层。现在你获
得了一个更有价值的程序，因为它有较高的质量，让我们在明天（未来)受益。
请将这种方法与“小心翼翼的事前设计”做个比较。推测性设计总是试图在任何一行代码诞生之前就先让系统拥有所有优秀质量，然后程序员将代码塞进这个强健的骨架中就行了。这个过程的问题在于：太容易猜错。如果运用重构，你就永远不会面临全盘错误的危险。程序自始至终都能保持一致的行为，而你又有机会为程序添加更多价值不菲的质量。
还有一种比较少见的重构游戏：找出不值得的间接层，并将它拿掉。这种间
接层常以中介函数形式出现，它也许曾经有过贡献，但芳华已逝。它也可能是个
组件，你本来期望在不同地点共享它，或让它表现出多态性，最终却只在一处用
到。**如果你找到这种“寄生式间接层”，请把它扔掉**。如此一来你会获得一个更
有价值的程序，不是因为它取得了更多的优秀质量，而是因为它以更少的间接层
获得一样多的优秀质量。

## 重构的难题

### 修改接口

## 重构与设计

重构肩负一项特殊使命：它和设计彼此互补。

如果你选择重构，问题的重点就转变了。你仍然做预先设计，但是不必一定找
出正确的解决方案。此刻的你只需要得到一个足够合理的解决方案就够了。你很肯
定地知道，在实现这个初始解决方案的时候，你对问题的理解也会逐渐加深，你可
能会察觉最佳解决方案和你当初设想的有些不同。只要有重构这把利器在手，就不
成问题，因为重构让日后的修改成本不再高昂。

有了重构，你就可以通过一条不同的途径来应付变化带来的风险。你仍旧需要
思考潜在的变化，仍旧需要考虑灵活的解决方案。但是你不必再逐一实现这些解决
方案，而是应该问问自己：“把一个简单的解决方案重构成这个灵活的方案有多大难
度？”如果答案是“相当容易”（大多数时候都如此），那么你就只需实现目前的简单
方案就行了。