# 代码的坏味道

我们并不试图给你一个何时必须重构的精确衡量标准。从我们的经验看来，**没**
**有任何量度规矩比得上一个见识广博者的直觉**。我们只会告诉你一些迹象，它会指
出“这里有一个可以用重构解决的问题”。你必须培养出自己的判断力，学会判断一
个类内有多少实例变量算是太大、一个函数内有多少行代码才算太长。

## Duplicated Code(重复代码)

最单纯的Duplicated Code就是“同一个类的两个函数含有相同的表达式”。这时候你需要做的就是采用Extract Method(I1O)提炼出重复的代码，然后让这两个地点都调用被提炼出来的那一段代码。

另一种常见情况就是“两个互为兄弟的子类内含相同表达式”。要避免这种情况，只需对两个类都使用Extract Method(110),然后再对被提炼出来的代码使用Pull Up Method(332),将它推入超类内。如果代码之间只是类似，并非完全相同，那么就得
运用Extract Method(110)将相似部分和差异部分割开，构成单独一个函数。然后你
可能发现可以运用Form Template Method(345)获得一个Template Method设计模式。如果有些函数以不同的算法做相同的事，你可以选择其中较清晰的一个，并使用
Substitute Algorithm(139)将其他函数的算法替换掉。

如果两个毫不相关的类出现Duplicated Code,你应该考虑对其中一个使用
Extract Class(149),将重复代码提炼到一个独立类中，然后在另一个类内使用这个
新类。但是，重复代码所在的函数也可能的确只应该属于某个类，另一个类只能调
用它，抑或这个函数可能属于第三个类，而另两个类应该引用这第三个类。你必须
决定这个函数放在哪儿最合适，并确保它被安置后就不会再在其他任何地方出现。

## Long Method(过长函数)

让小函数容易理解的真正关键在于一个好名字。如果你能给函数起个好名字，读者就可以通过名字了解函数的作用，根本不必去看其中写了些什么。

最终的效果是：你应该更积极地分解函数。我们遵循这样一条原则：每当感觉需要以注释来说明点什么的时候，我们就把需要说明的东西写进一个独立函数中，并以其用途（而非实现手法）命名。**我们可以对一组甚至短短一行代码做这件事。哪怕替换后的函数调用动作比函数自身还长，只要函数名称能够解释其用途，我也该毫不犹豫地那么做。关键不在于函数的长度，而在于函数“做什么”和“如何做”之间的语义距离。**

如果函数内有大量的参数和临时变量，它们会对你的函数提炼形成阻碍。
如果你尝试运用Extract Method(IlO),最终就会把许多参数和临时变量当作参数，传递
给被提炼出来的新函数，导致可读性几乎没有任何提升。此时，你可以经常运用
Replace Temp with Query(12O)来消除这些临时元素。Introduce Parameter Object(295)和Preserve Whole Object(288)则可以将过长的参数列变得更简洁一些。
如果你已经这么做了，仍然有太多临时变量和参数，那就应该使出我们的杀手锏：Replace Method with Method Object(l35).

如何确定该提炼哪一段代码呢？**一个很好的技巧是：寻找注释。它们通常能指出**
**代码用途和实现手法之间的语义距离。如果代码前方有一行注释，就是在提醒你：**
**可以将这段代码替换成一个函数，而且可以在注释的基础上给这个函数命名。**就算
只有一行代码，如果它需要以注释来说明，那也值得将它提炼到独立函数去。

## Large Class(过大的类)

类通常如果类内的数个变量有着相同的前缀或字尾，这就意味有机会把它们提炼到某个组件内。

和“拥有太多实例变量”一样，一个类如果拥有太多代码，往往也适合使用Extract
Class(149)和Extract Subclass(330)。这里有个技巧：先确定客户端如何使用它们，
然后运用Extract Interface(341)为每一种使用方式提炼出一个接口。这或许可以帮助
你看清楚如何分解这个类。

## Long Parameter List(过长参数列)

刚开始学习编程的时候，老师教我们：把函数所需的所有东西都以参数传递进去。这可以理解，因为除此之外就只能选择全局数据，而全局数据是邪恶的东西。
对象技术改变了这一情况：如果你手上没有所需的东西，总可以叫另一个对象给你。

因此，有了对象，你就不必把函数需要的所有东西都以参数传递给它了，只需传给
它足够的、让函数能从中获得自己需要的东西就行了。函数需要的东西多半可以在函
数的宿主类中找到。面向对象程序中的函数，其参数列通常比在传统程序中短得多。

## Divergent Change(发散式变化)

如果某个类经常因为不同的原因在不同的方向上发生变化，Divergent Change就出现了。当你看着一个类说：“呃，如果新加入一个数据库，我必须修改这三个函数：如果新出现一种金融工具，我必须修改这四个函数。”那么此时也许将这个对象
分成两个会更好，这么一来每个对象就可以只因一种变化而需要修改。

针对某一外界变化的所有相应修改，都只应该发生在单一类中，而这个新类内的所有内容都应该反应此变化。为此，你应该找出某特定原因而造成的所有变化，然后运用Extract Class(149)将它们提炼到另一个类中。

### Shotgun Surgery(霰弹式修改)

Shotgun Surgery类似Divergent Change,.但恰恰相反。如果每遇到某种变化，你
都必须在许多不同的类内做出许多小修改，你所面临的坏味道就是Shotgun Surgery。如果需要修改的代码散布四处，你不但很难找到它们，也很容易忘记某个重要的修改。
这种情况下你应该使用Move Method(142)和Move Field(146)把所有需要修改的
代码放进同一个类。如果眼下没有合适的类可以安置这些代码，就创造一个。通常
可以运用nline Class(154)把一系列相关行为放进同一个类。这可能会造成少量
Divergent Change,但你可以轻易处理它。
Divergent Change是指“一个类受多种变化的影响”，Shotgun Surgery则是指“一
种变化引发多个类相应修改”。这两种情况下你都会希望整理代码，使“外界变化”
与“需要修改的类”趋于一一对应。

### Feature Envy(依恋情结)

对象技术的全部要点在于：这是一种“将数据和对数据的操作行为包装在一起”
的技术。有一种经典气味是：函数对某个类的兴趣高过对自己所处类的兴趣。这种
孺慕之情最通常的焦点便是数据。无数次经验里，我们看到某个函数为了计算某个
值，从另一个对象那儿调用几乎半打的取值函数。疗法显而易见：把这个函数移至
另一个地点。你应该使用Move Method(142)把它移到它该去的地方。有时候函数中
只有一部分受这种依恋之苦，这时候你应该使用Extract Method(110)把这一部分提
炼到独立函数中，再使用Move Method(142)带它去它的梦中家园。

最经典的原则是：将总是在一起变换的东西放在一块

### Data Clumps(数据泥团)

数据项就像小孩子，喜欢成群结队地待在一块儿。你常常可以在很多地方看到
相同的三四项数据：两个类中相同的字段、许多函数签名中相同的参数。这些总是
绑在一起出现的数据真应该拥有属于它们自己的对象。首先请找出这些数据以字段
形式出现的地方，运用Extract Class(149)将它们提炼到一个独立对象中。然后将注
意力转移到函数签名上，运用Introduce Parameter Object(295)或Preserve Whole
Object(288)为它减肥。这么做的直接好处是可以将很多参数列缩短，简化函数调用。
是的，不必在意Data Clumps只用上新对象的一部分字段，只要以新对象取代两个（或更多)字段，你就值回票价了。

**一个好的评判办法是：删掉众多数据中的一项。这么做，其他数据有没有因而**
**失去意义？如果它们不再有意义，这就是个明确信号：你应该为它们产生一个新对象。**

### Primitive Obsession(基本类型偏执)

**对象的一个极大的价值在于：它们模糊（甚至打破）了横亘于基本数据和体积**
**较大的类之间的界限。**你可以轻松编写出一些与语言内置（基本)类型无异的小型类。

**对象技术的新手通常不愿意在小任务上运用小对象**——像是*结合数值和币种的*
*money类、由一个起始值和一个结束值组成的range类、电话号码或邮政编码(ZIP)*
等等的特殊字符串。**你可以运用Replace Data Value with Object(I75)将原本单独存在的数据值替换为对象，从而走出传统的洞窟，进入炙手可热的对象世界。**如果想要
替换的数据值是类型码，而它并不影响行为，则可以运用Replace Type Code with Class(218)将它换掉。如果你有与类型码相关的条件表达式，可运用Replace Type Code with Subclass(213)或Replace Type Code with State/Strategy(227)加以处理。

**如果你有一组应该总是被放在一起的字段，可运用Extract Class(149)。如果你在参数列中看到基本型数据，不妨试试Introduce Parameter Object(295)。如果你发现自己正从数组中挑选数据，可运用Replace Array with Object(186)。**

### Switch Statements（switch惊悚现身)

面向对象程序的一个最明显特征就是：少用switch(或case)语句。**从本质上说，switchi语句的问题在于重复**。你常会发现同样的switch语句散布于不同地点。如果要为它添加一个新的case子句，就必须找到所有switch语句并修改它们。面向对象中的多态概念可为此带来优雅的解决办法。

如果你只是在单一函数中有些选择事例，且并不想改动它们，那么多态就有点
杀鸡用牛刀了。这种情况下Replace Parameter with Explicit Methods(285)是个不错的选择。如果你的选择条件之一是null,可以试试Introduce Null Object(260)。

## Parallel Inheritance Hierarchies(平行继承体系)

Parallel Inheritance Hierarchies其实是Shotgun Surgery的特殊情况。在这种情况
下，每当你为某个类增加一个子类，必须也为另一个类相应增加一个子类。如果你
发现某个继承体系的类名称前缀和另一个继承体系的类名称前缀完全相同，便是闻
到了这种坏味道。消除这种重复性的一般策略是：让一个继承体系的实例引用另一个继承体系的实例。如果再接再励运用Move Method(142)和Move Field(146),就可以将引用端的继承体系消弭于无形。

## Lazy Class(冗赘类)

你所创建的每一个类，都得有人去理解它、维护它，这些工作都是要花钱的。
如果一个类的所得不值其身价，它就应该消失。项目中经常会出现这样的情况：某
个类原本对得起自己的身价，但重构使它身形缩水，不再做那么多工作：或开发者
事前规划了某些变化，并添加一个类来应付这些变化，但变化实际上没有发生。不论
上述哪一种原因，请让这个类庄严赴义吧。如果某些子类没有做足够的工作，试试
Collapse Hierarchy(344)。对于几乎没用的组件，你应该以Inline C1ass(154)对付它们。

## Speculative Generality(夸夸其谈未来性)





## Temporary Field(令人迷惑的暂时字段)

有时你会看到这样的对象：其内某个实例变量仅为某种特定情况而设。这样的代码让人不易理解，因为你通常认为对象在所有时候都需要它的所有变量。在变量未被使用的情况下猜测当初其设置目的，会让你发疯的。**请使用Extract Class(149)给这个可怜的孤儿创造一个家，然后把所有和这个变量相关的代码都放进这个新家。**也许你还可以使用Introduce Null Object(260)在“变量不合法”的情况下创建一个对象，从而避免写出条件式代码。
如果类中有一个复杂算法，需要好几个变量，往往就可能导致坏味道Temporary
Fild的出现。由于实现者不希望传递一长串参数（想想为什么），所以他把这些参
数都放进字段中。但是这些字段只在使用该算法时才有效，其他情况下只会让入迷
惑。这时候你可以利用Extract Class(149)把这些变量和其相关函数提炼到一个独立
类中。提炼后的新对象将是一个函数对象[Beck]。

## Message Chains(过度耦合的消息链)

如果你看到用户向一个对象请求另一个对象，然后再向后者请求另一个对象，然后再请求另一个对象…这就是消息链。实际代码中你看到的可能是一长串getThis()或一长串临时变量。采取这种方式，意味客户代码将与查找过程中的导航结构紧密耦合。一旦对象间的关系发生任何变化，客户端就不得不做出相应修改。这时候你应该使用Hide Delegate(IS7)。你可以在消息链的不同位置进行这种重构手法。理论上可以重构消息链上的任何一个对象，但这么做往往会把一系列对象(intermediate object).都变成Middle Man。通常更好的选择是：先观察消息链最终得到的对象是用来干什么的，看看能否以Extract Method(I1O)把使用该对象的代码提炼到一个独立函数中，再运用Move Method(142)把这个函数推入消息链。如果这条链上的某个对象有多位客户打算航行此航线的剩余部分，就加一个函数来做这件事。

## Middle Man(中间人)

但是人们可能过度运用委托。你也许会看到某个类接口有一半的函数都委托给其他类，这样就是过度运用。这时应该使用Remove Middle Man(I6O),直接和真正负责的对象打交道。如果这样“不干实事”的函数只有少数几个，可以运用InlineMethod(IlT)把它们放进调用端。如果这些Middle Man还有其他行为，可以运用Replace Delegation with Inheritance(35S)把它变成实责对象的子类，这样你既可以扩展原对象的行为，又不必负担那么多的委托动作。

## Data Class(纯稚的数据类)

所谓Data Class是指：它们拥有一些字段，以及用于访问（读写）这些字段的函
数，除此之外一无长物。这样的类只是一种不会说话的数据容器，它们几乎一定被
其他类过份细琐地操控着。这些类早期可能拥有public字段，果真如此你应该在别人
注意到它们之前，立刻运用Encapsulate Field(206)将它们封装起来。如果这些类内
含容器类的字段，你应该检查它们是不是得到了恰当的封装：如果没有，就运用
Encapsulate Collection(208)把它们封装起来。对于那些不该被其他类修改的字段，
请运用Remove Setting Method(30o).然后，找出这些取值/设值函数被其他类运用的地点。尝试以Move Method(142)把那些调用行为搬移到Data Class来。如果无法搬移整个函数，就运用Extract Method(110)产生一个可被搬移的函数。不久之后你就可以运用Hide Method(303)把这些取值/设值函数隐藏起来了。