# 重新组织函数

我的重构手法中，很大一部分是对函数进行整理，使之更恰当地包装代码。**几乎所有时刻，问题都源于Long Methods(过长函数)**。这很讨厌，因为它们往往包含太多信息，这些信息又被函数错综复杂的逻辑掩盖，不易鉴别。对付过长函数，一项重要的重构手法就是**Extract Method(110),它把一段代码从原先函数中提取出来，放进一个单独函数中**。**Inline Method(117)正好相反：将一个函数调用动作替换为该函数本体**。如果在进行多次提炼之后,意识到提炼所得的某些函数并没有做任何实质事情，或如果需要回溯恢复原先函数，我就需要Inline Method(117)。

Extract Method(110)最大的困难就是处理局部变量，而临时变量则是其中一个主要的困难源头。**处理一个函数时，我喜欢运用Replace Temp with Query(I20)去掉所有可去掉的临时变量。**如果很多地方使用了某个临时变量，我就会先运用Split Temporary Variable(128)将它变得比较容易替换。但有时候临时变量实在太混乱，难以替换。这时候我就需要使用Replace Method with Method Object(I35)。它让我可以分解哪怕最混乱的函数，代价则是引入一个新类。

参数带来的问题比临时变量稍微少一些，前提是你不在函数内赋值给它们。**如果你已经这样做了，就得使用Remove Assignments to Parameters(131)。**函数分解完毕后，我就可以知道如何让它工作得更好。也许我还会发现算法可以改进，从而使代码更清晰。这时我就使用Substitute Algorithm(139)引入更清晰的算法。

## Extract Method(提炼函数)

> 你有一段代码可以被组织在一起并独立出来。
>
> 将这段代码放进一个独立函数中，并让函数名称解释该函数的用途。

### 动机

有几个原因造成我喜欢简短而命名良好的函数。

- 如果每个函数的粒度都很小，那么函数被**复用**的机会就更大；
- 这会使高层函数读起来就像一系列**注释**；
- 如果函数都是细粒度，那么函数的**覆写**也会更容易些。

### 做法

1. 创造一个新函数，根据这个函数的意图来对它命名（**以它“做什么”来命名**，而不是以它“怎样做”命名)。

2. 将提炼出的代码从源函数复制到新建的目标函数中。
3. 仔细检查提炼出的代码，看看其中**是否引用了“作用域限于源函数”的变量(**包括局部变量和源函数参数)。
4. 检查被提炼代码段，看看是否有任何局部变量的值被它改变。**如果一个临时变量值被修改了，看看是否可以将被提炼代码段处理为一个查询**，并将结果赋值给相关变量。如果很难这样做，或如果被修改的变量不止一个，你就不能仅仅将这段代码原封不动地提炼出来。你可能需要先使用Split Temporary ariable(128),然后再尝试提炼。也可以使用Replace Temp with Query(120)
   将临时变量消灭掉（请看“范例”中的讨论）。
5. 将被提炼代码段中需要读取的局部变量，当作参数传给目标函数。

### 范例

#### 有局部变量

此重构手法的**难度在于局部变量，包括传进源函数的参数和源函数所声明的临时变量**。局部变量的作用域仅限于源函数。

局部变量最简单的情况是：被提炼代码段只是读取这些变量的值，并不修改它们。
这种情况下我可以简单地将它们当作参数传给目标函数。所以如果我面对下列函数：

```java
void printowing(){
    Enumeration e =orders.elements();
	double outstanding 0.0;
    
	printBanner ();
    
	//calculate outstanding
	while (e.hasMoreElements()){
        Order each =(Order)e.nextElement ();
		outstanding +each.getAmount ();
    }

	//print details
	System.out printIn("name:"+_name);
	System.out.println("amount "+outstanding);
}

```

可以将打印信息提炼为一个函数

```java
void printDetails(double outstanding){
    System.out.println("name:"+_name);
	System.out.printin("amount"+outstanding);
}
```

#### 对局部变量再赋值

如果被提炼代码

段对局部变量赋值，问题就变得复杂了。这里我们只讨论临时变量的问题。如果你发现源函数的参数被赋值，应该马上使用Remove Assignments to Parameters (131).

被赋值的临时变量有两种情况：

- 只在被提炼的代码中使用：一起提炼出去
- 被提炼的代码段之外也使用类这个变量
  - 在被提炼的代码块之后未被再使用：直接在目标中修改
  - 在被提炼的代码块之后继续使用：让目标函数返回改变量修改后的值

```java
void printowing(){
    Enumeration e =_orders.elements();
	double outstanding =0.0;
	printBanner ()
	//calculate outstanding
	while (e.hasMoreElements ()){
        Order each =(Order)e.nextElement ();
		outstanding +=each.getAmount ()	;
    }
	printDetails(outstanding);
}

```

提取计算代码

```java
void printOwing(）{
	printBanner ()
	double outstanding =getOutstanding();
	printDetails(outstanding);
}

double getOutstanding(){
    	Enumeration e =_orders.elements ()
	double outstanding =0.0;
	while (e.hasMoreElements ()){
        Order each=(order）e.nextElement(）;
		outstanding +=each.getAmount ()
    }
	return outstanding;
}
```

Enumeration变量e只在被提炼代码段中用到，所以可以将它整个搬到新函数
中。double变量outstanding在被提炼代码段内外都被用到，所以必须让提炼出
来的新函数返回它。编译测试完成后，我就把回传值改名，遵循我的一贯命名原则：

```java
double getOutstanding(){
    Enumeration e =_orders.elements();
	double result = 0.0;
	while (e.hasMoreElements()){
    	order each =(order)e.nextElement ()；
		Result+=each.getAmount ()；
	}
	return result;
}

```

提炼后的代码

```java
void printOwing(double prevousAmount){
    double outstanding = previousAmount *1.2;
    printBanner();
    outding = getOutstanding(outstanding);
    printDatails(outstanding);
}

double getOutstanding(double initialValue){
    double result = initialValue;
    Enumeration e = _orders.elements();
    while(e.hasMoreElements()){
        Order each = (Order)e.nextElement();
        result += each.getAmount();
    }
    return result;
}
```

编译并测试后，我再将变量outstanding的初始化过程整理一下：

```java
void printowing(double previousAmount)(
	printBanner ()
	double outstanding getoutstanding(previousAmount 1.2);
	printDetails(outstanding);
)
```

## Inline Method(内联函数)

> 一个函数的本体与名称同样清楚易懂。
>
> 在函数调用点插入函数本体，然后移除该函数。

### 动机

有时候你会遇到**某些函数，其内部代码和函数名称同样清晰易读**。也可能你重构了该函数，使得其内容和其名称变得同样清晰。果真如此，你就应该去掉这个函数，直接使用其中的代码。间接性可能带来帮助，但非必要的间接性总是让人不舒服。

另一种需要使用Inline Method(117)的情况是：**你手上有一群组织不甚合理的函数。你可以将它们都内联到一个大型函数中，再从中提炼出组织合理的小型函数。**Kent Beck发现，实施Replace Method with Method Object(I35)之前先这么做，往往可以获得不错的效果。你可以把所要的函数（有着你要的行为）的所有调用对象的函数内容都内联到函数对象中。比起既要移动一个函数、又要移动它所调用的其他所有函数，将整个大型函数作为整体来移动会比较简单。

当然，**间接层有其价值，但不是所有间接层都有价值。**试着使用内联手法，我可以找出那些有用的间接层，同时将那些无用的间接层去除。

### 做法

1. 检查函数，确定它不具多态性
2. 找出这个函数的所有调用点
3. 将这个函数的所有被调用的点都替换成函数本体
4. 编译，调试

如果你遇到了复杂情况，就不用改使用这个重构手法

## Inline Temp(内联临时变量)

> 你有一个临时变量，只被一个简单表达式赋值一次，而它妨碍了其他重构手法。
>
> 将所有对该变量的引用动作，替换为对它赋值的那个表达式自身。
>
> ```java
> double baseprice anorder.baseprice();
> return (basePrice 1000)
>     
>     ==>
>     
> return (anorder.baseprice()>1000)
> ```

### 动机

Inline Temp(119)多半是作为Replace Temp with Query(120)的一部分使用的，所以真正的动机出现在后者那儿。唯一单独使用Inline Temp(119)的情况是：你发现某个临时变量被赋予某个函数调用的返回值。一般来说，这样的临时变量不会有任何危害，可以放心地把它留在那儿。但如果这个临时变量妨碍了其他的重构手法，例如Extract Method(1l0),你就应该将它内联化。

## Replace Temp with Query(以查询取代临时变量)

> 你的程序**以一个临时变量保存某一表达式的运算结果**。
>
> 将这个表达式提炼到一个独立函数中。将这个临时变量的所有引用点替换为对新函数的调用。此后，新函数就可被其他函数使用。

## Replace Method with Method Object(以函数对象取代函数)

> 你有一个大型函数，其中对局部变量的使用使你无法采用Extract Method(Il0)。
>
> 将这个函数放进一个单独对象中，如此一来局部变量就成了对象内的字段。然后你
> 可以在同一个对象中将这个大型函数分解为多个小型函数。

### 动机

Replace Method with Method Object(I35)会**将所有局部变量都变成函数对象的字段**。然后你就可以对这个新对象使用Extract Method(I10)创造出新函数，从而将原本的大型函数拆解变短。

### 做法

1. 建立一个新类，根据待处理函数的用途，为这个类命名
2. 在新类中建立一个final字段，用以保存原先大型函数所在的对象。我们将这个字段称为“源对象”。同时，针对原函数的每个临时变量和每个参数，在新类中建立一个对应的字段保存之。
3. 在新类中建立一个构造函数，接受源对象及源函数的所有参数作为参数
4. 在新类中建立一个computr()函数（Java中常用于计算或处理逻辑）
5. 将原函数的代码复制到compute()函数中。如果需要调用源对象的任何函数，请通过源对象字段调用。
6. 编译
7. 将旧函数的函数本体替换为这样一条语句：“创建上述新类的一个新对象，而后调用其中的compute()函数”。

### 范例

```java
Class Account
int gamma (int inputVal,int quantity,int yearToDate){
    int importantvaluel (inputval quantity)+delta();
	int importantValue2 (inputval yearToDate)+100;
	if ((yearToDate -importantValuel)>100)
		importantValue2 -20;
	int importantvalue3 importantvalue2 7;
	//and so on.
	return importantValue3 -2 importantValuel;
}

```

为了把这个函数变成一个函数对象，我首先需要声明一个新类。在此新类中我应该提供一个final字段用以保存源对象；对于函数的每一个参数和每一个临时变量，也以一个字段逐一保存。
