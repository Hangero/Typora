# C++ 虚函数

- 虚函数可以让我们在子类中重写方法。
- 格式

```cpp
claee 父类名{
   //virtual + 函数
   virtual void GetName(){
       .....
   }
}
```

- 虚函数的例子，通常有三步。

> 第一步，定义基类，声明基类函数为 `virtual` 的。
> 第二步，定义派生类(继承基类)，派生类实现了定义在基类的 `virtual` 函数。
> 第三步，声明基类指针，并指向派生类，调用`virtual`函数，此时虽然是基类指针，但调用的是派生类实现的基类`virtual` 函数。

例子：

```cpp
//基类
class Entity
{
public:
    std::string GetName() {return "Entity";}
};

//派生类
class Player : public Entity
{
private: 
 std::string m_Name; 
public: 
 Player(const std::string& name):m_Name (name) {}  //构造函数
 std::string GetName() {return m_Name;}
};

int main(){
 Entity* e = new Entity();//不用手动删除，因为程序会终止（对象被自动删除）
 std::cout << e->GetName() << std::endl; 
 Player* p = new Player("cherno"); 
 std::cout << p->GetName() << std::endl;
}
---------------------------------
//输出
Entity
cherno
```

上述代码虽能够成功运行，**但是如果使用多态的概念来看，目前为止我们写的这些都是不合格的**

如果我引用这个Player并把它当成Entity类型，就会出现问题，例如：

```cpp
int main(){
 Entity* e = new Entity();//不用手动删除，因为程序会终止（对象被自动删除）
 std::cout << e->GetName() << std::endl; 
 Player* p = new Player("cherno"); 
 std::cout << p->GetName() << std::endl;
 //声明基类指针，并指向派生类
 Entity* entity = p; //p是一个Player类型的指针，它是一个Player，但是我把它指向了一个Entity
 std::cout << entity->GetName() << std::endl; 
}
```

输出：

```cpp
Entity
cherno
Entity //运行代码，你会看见打印出了"Entity"，但是我们希望的是打印Player
```

我们希望的是打印Player,因为虽然我们指向的是个Entity*，但是它实际上是一个Player，它是一个Player类的实例，但实际上运行代码，你会看见打印出了"Entity"，why?

```cpp
Entity* entity = p;
```

举一个更清晰的例子：

```cpp
//基类
class Entity
{
public:
    std::string GetName() {return "Entity";} 
};

//派生类
class Player : public Entity
{
private: 
 std::string m_Name; 
public: 
 Player(const std::string& name):m_Name (name) {}  //构造函数
 std::string GetName() {return m_Name;}
};

void printName(Entity* entity){
 std::cout << entity -> GetName() << std::endl;
}

int main(){
 Entity* e = new Entity();
 printName(e); //我们这儿做的就是调用entity的GetName函数，我们希望这个GetName作用于Entity
 Player* p = new Player("cherno"); 
 printName(p); //printName(Entity* entity)，没有报错是因为Player也是 Entity类型。同样我们希望这个GetName作用于Player
}
```

输出：

```cpp
Entity
Entity
```

两次输出都是Entity，**原因在于如果我们在类中正常声明函数或方法，当调用这个方法的时候，它总是会去调用属于这个类型的方法**，而`void printName(Entity* entity);`参数类型是`Entity*`,意味着它会调用Entity内部的GetName函数，**它只会在Entity的内部寻找和调用GetName**.

但是我们希望C++能意识到,在这里我们传入的其实是一个Player，所以请调用Player的GetName。**此时就需要使用虚函数了。**

- 虚函数引入了一种要**动态分配**的东西，一般通过虚表（vtable）来实现编译。虚表就是一个包含类中所有虚函数映射的列表，通过虚表我们就可以在运行时找到正确的被重写的函数。
- 简单来说，你需要知道的就是**如果你想重写一个函数，你么你必须要把基类中的原函数设置为虚函数**

```cpp
//基类
class Entity
{
public:
    virtual std::string GetName() {return "Entity";} //第一步，定义基类，声明基类函数为 virtual的。
};

//派生类
class Player : public Entity
{
private: 
    std::string m_Name; 
public: 
    Player(const std::string& name):m_Name (name) {} 
    //第二步，定义派生类(继承基类)，派生类实现了定义在基类的 virtual 函数。
    std::string GetName() override {return m_Name;}  //C++11新标准允许给被重写的函数用"override"关键字标记,增强代码可读性。
};

void printName(Entity* entity){
    std::cout << entity -> GetName() << std::endl;
}

int main(){
    Entity* e = new Entity();
    printName(e); 
    //第三步，声明基类指针，并指向派生类，调用`virtual`函数，此时虽然是基类指针，但调用的是派生类实现的基类virtual函数。Entity* p = new Player("cherno");也可以
    Player* p = new Player("cherno"); 
    printName(p); 
}
```