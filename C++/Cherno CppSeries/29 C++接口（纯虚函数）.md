# C++ 接口（纯虚函数）

- **纯虚函数优点**

> 防止派生类忘记实现虚函数，**纯虚函数使得派生类必须实现基类的虚函数**。
> 在某些场景下，创建基类对象是不合理的，含有纯虚拟函数的类称为**抽象类**，它**不能直接生成对象。**

- **声明方法**: 在基类中纯虚函数的方法的后面加 **=0**

```cpp
virtual void funtion()=0;
virtual std::string GetName() = 0;
```

- C++中的纯虚函数本质上与其他语言（bi如Java或C#）中的抽象方法或接口相同。
- 纯虚函数与虚函数的区别在于，纯虚函数的基类中的`virtual`函数，只定义了，但不实现。实现交给派生类来做。
- **只能实例化一个实现了所有纯虚函数的类**。**纯虚函数必须被实现**，然后我们才能创建这个类的实例。
- 纯虚函数允许我们在基类中定义一个没有实现的函数，然后**强制子类**去实现该函数。
- 实际上，其他语言有interface关键字而不是叫class，但C++没有。接口只是C++的类而已。
- 在面向对象程序设计中，创建一个只包含未实现方法然后交由子类去实际实现功能的类是非常普遍的,这通常被称为接口。**接口就是一个只包含未实现的方法并作为一个模板的类**。并且由于此**接口类**实际上不包含方法实现，所以我们**无法实例化**这个类。

例子：

```cpp
//基类
class Entity
{
public:
    virtual std::string GetName() = 0; //声明为纯虚函数。请记住，这仍然被定义为虚函数，但是=0实际上将它变成了一个纯虚函数，这意味着如果你想实例化这个类，那么这个函数必须在子类中实现
};

//派生类
class Player : public Entity
{
private: 
 std::string m_Name; 
public: 
 Player(const std::string& name):m_Name (name) {} 
 std::string GetName() override {return m_Name;} //实现纯虚函数
};

void printName(Entity* entity){
 std::cout << entity -> GetName() << std::endl;
}

int main(){
// Entity* e = new Entity();  //会报错，在这里我们必须给它一个实际上实现了这个函数的子类
 Entity* e = new Player("");  //ok
 printName(e); 

 Player* p = new Player("cherno"); 
 printName(p); 
}
```

> 再看一个更好的例子
> 假设我们想编写一个打印这儿所有类名的函数。

```cpp
class Printable{   //接口。其实就是个类。之所以称它为接口，只是因为它有一个纯虚函数，仅此而已。
public:
    virtual std::string GetClassName()= 0;
};
//基类
class Entity : public Printable
{
public:
    virtual std::string GetName() {return "Entity";}
 std::string GetClassName() override {return "Entity";} //实现接口的纯虚函数
};

//派生类
class Player : public Entity //因为Player已经是Entity（已有接口），所以Player不用去实现Printable接口
{
private: 
 std::string m_Name; 
public: 
 Player(const std::string& name):m_Name (name) {} 
 std::string GetName() override {return m_Name;} 
 std::string GetClassName() override {return "Player";} //实现接口的纯虚函数
};

void  Print(Printable* obj){  //我们需要某种类型能提供GetClassName函数，这就是接口。所有的打印都来自于这个Print函数，它接受printable对象，它不关心实际是什么类
    std::cout <<obj ->GetClassName() << std::endl;
}

int main(){
 Entity* e = new Entity();
 Player* p = new Player("cherno"); 
 Print(e);
 Print(p);
}
//输出：
Entity
Player
```

上例中，如果Player不是Entity的话，就要添加接口，如下

```cpp
class Player : public OtherClass,Printable  //加逗号，添加接口Printable
{
 ....
 std::string GetName() override {return m_Name;} 
};
```