# 移动语义

> 如果我们只是移动对象而不是复制对象，那么性能会提高



## 为什么需要移动语义

首先来讲讲我们为什么需要移动语义，很多时候我们只是单纯创建一些右值，然后赋给某个对象用作构造函数。

这时候会出现的情况是，我们首先需要在main函数里创建这个右值对象，然后复制给这个对象相应的成员变量。

如果我们可以直接把这个右值变量移动到这个成员变量而不需要做一个额外的复制行为，程序性能就这样提高了。

```cpp
#include <iostream>
#include <cstring>
 
class String {
public:
    String() = default;
    String(const char* string) {
        printf("Created!\n");
        m_Size = strlen(string);
        m_Data = new char[m_Size];
        memcpy(m_Data, string, m_Size);
    }
 
    String(const String& other) {
        printf("Copied!\n");
        m_Size = other.m_Size;
        m_Data = new char[m_Size];
        memcpy(m_Data, other.m_Data, m_Size);
    }
 
    ~String() {
        delete[] m_Data;
    }
 
    void Print() {
        for (uint32_t i = 0; i < m_Size; ++i)
            printf("%c", m_Data[i]);
 
        printf("\n");
    }
private:
    char* m_Data;
    uint32_t m_Size;
};
 
class Entity {
public:
    Entity(const String& name)
        : m_Name(name) {}
    void PrintName() {
        m_Name.Print();
    }
private:
    String m_Name;
};
 
int main(int argc, const char* argv[]) {
    Entity entity(String("Cherno"));
    entity.PrintName();
 
    return 0;
}
```

程序的输出结果是

```cpp
Created!
Copied!
Cherno
```

可以看到中间发生了一次copy，实际上这次copy发生在Entity的初始化列表里。

从String的复制构造函数可以看到，复制过程中还申请了新的内存空间！这会带来很大的消耗。

## 移动构造函数

现在让我们为String写一个移动构造函数并为Entity重载一个接受右值引用参数的构造函数，另外我们还将原来的构造函数注释掉了。

```cpp
    String(String&& other) {
        printf("Moved!\n");
        m_Size = other.m_Size;
        m_Data = other.m_Data;
        other.m_Data = nullptr;
        other.m_Size = 0;
    }
 
   ~String() {
        printf("Destroyed!\n");
        delete[] m_Data;
    }
 
    Entity(String&& name)
        : m_Name(name) {}
 
    // Entity(const String& name)
    //     : m_Name(name) {}
 
```

输出为

```cpp
Created!
Copied!
Destroyed!
Cherno
Destroyed!
```

幸运的是可以看到没有报错，确实调用了新写的Entity的构造函数并输出了结果。

但是不幸的是还是调用了String的赋值构造函数，问题出在哪呢？

实际上接受右值的函数在参数传进来后其右值属性就退化了，所以给m_Name的参数仍然是左值，还是会调用复制构造函数。

解决的办法是将name转型，

```cpp
Entity(String&& name)
    :m_Name((String&&)name) {}
```

但是这样的作法并不优雅，C++为了提供了更为优雅的做法

```cpp
Entity(String&& name)
    :m_Name(std::move(name)) {}
```

修改之后的输出结果为

```cpp
Created!
Moved!
Destroyed!
Cherno
Destroyed
```

> **每个表达式都有两种特征：一是类型二是值类别**。很多人迷惑的右值引用为啥是个左值，那是因为右值引用是它的类型，左值是它的值类别。
> 想理解右值首先要先知道类型和值类别的区别；其次是各个值类别的定义是满足了某种形式它就是那个类别，经常说的能取地址就是左值，否则就是右值，这是定义之上的不严谨经验总结，换句话说，是左值还是右值是强行规定好的，你只需要对照标准看这个表达式满足什么形式就知道它是什么值类别了。
> 为什么要有这个分类，是为了语义，当一个表达式出现的形式表示它是一个右值，就是告诉编译器，我以后不会再用到这个资源，放心大胆的转移销毁，这就可以做优化，比如节省拷贝之类的。
> **`std::move`的作用是无条件的把表达式转成右值**，也就是rvalue_cast，虽然编译器可以推断出左右值，但人有时比编译器“聪明”，人知道这个表达式的值以后我不会用到，所以可以在正常情况下会推成左值的地方强行告诉编译器，我这是个右值，请你按右值的语义来做事。

## 移动赋值运算符

```cpp
String dest((String&&)string);
String dest = std::move(string);
```

我可以在这里进行一个赋值操作，问题是，我们在这里是创建一个新对象，而不是在这里发生移动赋值操作，正如你所见，我们把变量类型放在前面，然后是变量名，这是一个全新的对象，它正在被构造，因此他会使用移动构造函数，这就引出了**移动赋值运算符号**

**运算符像一种函数**

上面的例子讲了关于移动构造函数的例子，然而有时候我们想要将一个已经存在的对象移动给另一个已经存在的对象，就像下面这样。

```cpp
int main(int argc, const char* argv[]) {
    String apple = "apple";
    String orange = "orange";
 
    printf("apple: ");
    apple.Print();
    printf("orange: ");
    orange.Print();
 
    apple = std::move(orange);
 
    printf("apple: ");
    apple.Print();
    printf("orange: ");
    orange.Print();
    return 0;
}
```

我们需要的是一个移动赋值运算符重载

```cpp
    String& operator=(String&& other) {
        printf("Moved\n");
        if (this != &other) {//自赋值判断
            delete[] m_Data;
 
            m_Size = other.m_Size;
            m_Data = other.m_Data;
 
            other.m_Data = nullptr;
            other.m_Size = 0;
        }
        return *this;
    }
```

我们是移动，因此我们需要覆盖当前对象，因为当前对象可能已经分配了一些内存，为防止内存泄漏，首先删除当前数据。因此不能出现自己移动到自己，这样只会删除数据



注意这里的实现还是有点讲究的，因为移动赋值相当于把别的对象的资源都偷走，那如果移动到自己头上了就没必要自己偷自己 。

更重要的是**原来自己的资源一定要释放掉**，否则指向自己原来内容内存的指针就没了，这一片内存就泄露了！

上述输出结果是

```cpp
Created!
Created!
apple: apple
orange: orange
Moved
apple: orange
orange:
Destroyed!
Destroyed!
```

很漂亮，orange的内容被apple偷走了。





![陈硕大佬关于识别C++代码质量的回答](https://img2022.cnblogs.com/blog/2744240/202203/2744240-20220317195145892-1024402652.png)









