# 名称空间

1.命名空间是C++独有，C是没有的，故写C时会有命名冲突的风险。

2.**类本身就是名称空间** 。

> 类外使用一个类内的成员需要加`::`

3.命名空间（名称空间）的主要目的是**避免命名冲突**，便于管理各类命名函数。使用名称空间的原因，是因为我们希望**能够在不同的上下文中调用相同的符号**。

```cpp
#include <iostream>
#include <string>
#include <algorithm>
namespace apple {
    void print(const char *text) {
        std::cout << text << std::endl;
    }
}

namespace orange {
    void print(const char *text) {
        std::string temp = text;
        std::reverse(temp);
        std::cout << temp << std::endl;
    }
}
int main() {
    //using namespace apple::print; //单独引出一个print函数
    //using namespace apple;//引出apple名称空间的所有成员

    apple::print("hello");  //输出正常text
    orange::print("world"); //输出反转的text
}
```

拓展:详情请参考原文链接：https://zhuanlan.zhihu.com/p/441602923

大型程序往往会使用多个独立开发的库，这些库会定义大量的全局名字，如类、函数和模板等，不可避免会出现某些名字相互冲突的情况。命名空间`namespace`分割了全局命名空间，其中每个命名空间是一个作用域。

```cpp
namespace foo {
    class Bar { /*...*/ };
}  // 命名空间结束后无需分号
```

**命名空间定义**

**1. 每个命名空间都是一个作用域**

> 同其他作用域类似，命名空间中的每个名字都必须表示该空间内的唯一实体。因为不同命名空间的作用域不同，所以在不同命名空间内可以有相同名字的成员。

**2. 命名空间可以不连续**

> 命名空间的定义可以不连续的特性使得我们可以将几个独立的接口和实现文件组成一个命名空间，定义多个类型不相关的命名空间也应该使用单独的文件分别表示每个类型。

**3. 模板特例化**

何为模板特例化请参考：[http://t.csdn.cn/hpQOF](https://link.zhihu.com/?target=http%3A//t.csdn.cn/hpQOF)

> 模板特例化必须定义在原始模板所属的命名空间中，和其他命名空间名字类似，只要我们在命名空间中声明了特例化，就能在命名空间外部定义它了：

```cpp
// 我们必须将模板特例化声明成std的成员
namespace std {
    template <> struct hash<Foo>;
}

// 在std中添加了模板特例化的声明后，我们就可以在命名空间std的外部定义它了
template<> struct std::hash<Foo> {
    size_t operator()(const Foo& f) const {
        return hash<string>()(f.str) ^
            hash<double>()(f.d);
    }
};
```

**4. 全局命名空间**

全局作用域中定义的名字（即在所有类、函数以及命名空间之外定义的名字）也就是定义在全局命名空间`global namespace`中。全局作用域是隐式的，所以它并没有名字，下面的形式表示全局命名空间中一个成员：

```cpp
::member_name
```

**5. 嵌套的命名空间**

```cpp
namespace foo {
    namespace bar {
        class Cat { /*...*/ };
    }
}

// 调用方式
foo::bar::Cat
```

**6. 内联命名空间**

C++11新标准引入了一种新的嵌套命名空间，称为内联命名空间`inline namespace`。内联命名空间可以被外层命名空间直接使用。定义内联命名空间的方式是在关键字`namespace`前添加关键字`inline`：

```cpp
// inline必须出现在命名空间第一次出现的地方
inline namespace FifthEd {
    // ...
}
// 后续再打开命名空间的时候可以写inline也可以不写
namespace FifthEd {  // 隐式内敛
    // ...
}
```

当应用程序的代码在一次发布和另一次发布之间发生改变时，常使用内联命名空间。例如我们把第五版`FifthEd`的所有代码放在一个内联命名空间中，而之前版本的代码都放在一个非内联命名空间中：

```cpp
namespace FourthEd {
    // 第4版用到的其他代码
    class Cat { /*...*/ };
}

// 命名空间cplusplus_primer将同时使用这两个命名空间
namespace foo {
#include "FifthEd.h"
#include "FoutthEd.h"
}
```

因为`FifthEd`是内联的，所以形如`foo::`的代码可以直接获得`FifthEd`的成员，如果我们想用到早期版本的代码，则必须像其他嵌套的命名空间一样加上完整的外层命名空间名字：

```cpp
foo::FourthEd::Cat
```

**7. 未命名的命名空间**

关键字`namespace`后紧跟花括号括起来的一系列声明语句是未命名的命名空间`unnamed namespace`。未命名的命名空间中定义的变量具有静态生命周期：它们在第一次使用前被创建，直到程序结束时才销毁。

> *Tips：每个文件定义自己的未命名的命名空间，如果两个文件都含有未命名的命名空间，则这两个空间互相无关。在这两个未命名的命名空间里面可以定义相同的名字，并且这些定义表示的是不同实体。如果一个头文件定义了未命名的命名空间，则该命名空间中定义的名字将在每个包含了该头文件的文件中对应不同实体。*

和其他命名空间不同，未命名的命名空间仅在特定的文件内部有效，其作用范围不会横跨多个不同的文件。未命名的命名空间中定义的名字的作用域与该命名空间所在的作用域相同，如果未命名的命名空间定义在文件的最外层作用域中，则该命名空间一定要与全局作用域中的名字有所区别：

```cpp
// i的全局声明
int i;
// i在未命名的命名空间中的声明
namespace {
    int i;  
}
// 二义性错误: i的定义既出现在全局作用域中, 又出现在未嵌套的未命名的命名空间中
i = 10;
```

> *未命名的命名空间取代文件中的静态声明：*
> *在标准C++引入命名空间的概念之前，程序需要将名字声明成`static`的以使其对于整个文件有效。在文件中进行静态声明的做法是从C语言继承而来的。在C语言中，声明为`static`的全局实体在其所在的文件外不可见。* ***在文件中进行静态声明的做法已经被C++标准取消了，现在的做法是使用未命名的命名空间。***