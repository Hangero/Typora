# C++中的静态

static关键字两种用法

- 在类或结构体外部使用static关键字

> **这意味着你定义的函数和变量只对它的声明所在的cpp文件（编译单元）是“可见”的**。换句话说此时static修饰的符号,（在link的时候）它只对定义它的翻译单元(.obj)可见（internal linkage）。

- 在类或结构体内部使用static关键字

> 此时表示这部分内存（static变量）是这个类的所有实例共享的。即：该静态变量在类中创建的所有实例中，静态变量只有一个实例。**一个改变就改变所有。**

类中的静态方法也一样，静态方法中没有该实例的指针（this）。在类中没有实例会传递给该方法。

## C++类和结构体外的静态

如果不用static定义全局变量，在别的翻译单元可以用extern int a这样的形式，这被称为 external linkage或external linking。

重点是，要让函数和变量标记为静态的，除非你真的需要它们跨翻译单元链接。

**两个全局变量的名字不能一样**

```cpp
//a.cpp中
int s_var = 5;

//main.cpp中
int s_var = 10;
int main(){
    std::cout << s_var << std::endl;
}
```

这样将会linker失败！

```text
error: ld returned 1 exit status
```

解决方法：

> 1.static声明

```cpp
//a.cpp中
static int s_var = 5;

//main.cpp中
int s_var = 10;
int main(){
    std::cout << s_var << std::endl;
}

//输出10
```

> 2.extern声明（将其变成另一个变量的引用）

```cpp
//a.cpp中
int s_var = 5;

//main.cpp中
extern int s_var;   //注意这里没有了赋值
int main(){
    std::cout << s_var << std::endl;
}

//输出5
//这被称为 external linkage或external linking。
```

==在类或结构体的外部使用static修饰变量和函数，会让他们拥有不被外部翻译单元链接的能力==，只会在它被声明的C++文件中被"看见"

### 为什么使用`static`

想一下，为什么要在类中使用`private`？

如果不需要变量是全局变量，就尽可能地多使用静态变量

全局变量是不好的，少使用全局变量



## C++类和结构体中的静态

 

- **静态方法**不能访问**非静态变量**
- **静态方法没有类实例**
- 本质上你在类里写的每个**非静态方法**都会获得当前的类实例作为参数（this指针）
- 静态成员变量在编译时存储在静态存储区，即**定义过程应该在编译时完成**，因此**一定要在类外进行定义**，但可以不初始化。 **静态成员变量是所有实例共享的**，但是其**只是在类中进行了声明，并未定义或初始化**（分配内存），类或者类实例就无法访问静态成员变量，这显然是不对的，**所以必须先在类外部定义**，也就是分配内存。

> 在几乎所有面向对象的语言里，static在一个类中意味着特定的东西。**如果是static变量，这意味着在类的所有实例中，这个变量只有一个实例。**比如一个entity类，有很多个entity实例，若其中一个实例更改了这个static变量，它会在所有实例中反映这个变化。这是因为即使创建了很多实例，static的变量仍然只有一个。正因如此，**通过类实例来引用静态变量是没有意义的**。因为这就像类的全局实例。
> 静态方法也是一样，无法访问类的实例。静态方法可以被调用，不需要通过类的实例。而在静态方法内部，你不能写引用到类实例的代码，因为你不能引用到类的实例。



**静态方法不能访问非静态变量，原因就是静态方法没有类实例，我们在编写类的时候，本质上我们在类里写的每个非静态方法都会获得当前的类实例作为参数（this指针）。**



```cpp
//在类外面写一个print()函数
static void print(Entity e)
{
 cout << e.x << endl;  // 成功运行
}
```

我们刚刚写的方法，**本质上就是一个类的非静态方法在编译时的真正样子**

但如果我把**Entity实例去掉**，就是**把static关键字加到类方法时所做的**

```cpp
//在类外面写一个print()函数
static void print()       //把Entity实例去掉
{
 cout << e.x << endl;  // 报错
}
```

这就是问什么会错，他不知道要怎么访问Entity的x，y因为你没有给他一个Entity的引用。



## C++中的局部静态(`Loacl Static`)

> 在局部作用域中可以使用static来声明一个变量，这和前两种有所不同。这一种情况需要考虑变量的生命周期和作用域。
> 生命周期：变量实际存在的时间；作用域：指可以访问变量的范围。
> 静态局部（local static）变量允许我们声明一个变量，它的生命周期基本相当于整个程序的生命周期，然而它的作用范围被限制在这个作用域内。

```cpp
#include <iostream>

void Function（）
{   //这句的意思是当我第一次调用这个函数时它的值被初始化为0,后续调用不会再创建一个新的变量
 static int i = 0；
 i++；  //如果上一行没有static结果会是每次调用这个函数i的值被设为0，然后i自增1向控制台输出1
 std::cout << i << std::endl；
}

int main()
{
 Function（）；
 Function（）；
 Function（）；
 std:：cin.get（）
}
```

这其实就如同在函数外声明一个全局变量，但是全局变量的问题是可以**在任何地方**都可以被访问到

而局部静态是所有同名函数公用的“全局变量”。