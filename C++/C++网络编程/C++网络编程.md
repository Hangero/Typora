# C++网络编程

### 参考资料

- https://mmoaay.gitbooks.io/boost-asio-cpp-network-programming-chinese/content/Chapter1.html
- https://zhuanlan.zhihu.com/p/119085959
- https://www.llfc.club/category?catid=225RaiVNI8pFDD5L4m807g7ZwmF#!aid/2LfzYBkRCfdEDrtE6hWz8VrCLoS

## 网络编程

C++网络编程是使用C++语言进行网络应用程序开发的过程。它涉及使用C++编写客户端和服务器端代码，以便它们可以在计算机网络上进行通信。

C++网络编程可以用于创建各种网络应用程序，包括Web服务器、网络游戏、实时通信应用程序和分布式系统等。下面是一些常用的C++网络编程库和概念：

1. Socket编程：在C++中，可以使用Socket API来进行网络编程。Socket是一种编程接口，允许应用程序通过网络进行通信。通过Socket，可以建立网络连接、发送和接收数据等。
2. TCP和UDP协议：C++网络编程可以使用TCP（传输控制协议）或UDP（用户数据报协议）来进行通信。TCP提供可靠的、面向连接的通信，而UDP提供无连接的通信，适用于实时应用程序和广播通信等场景。
3. Boost.Asio：Boost.Asio是一个流行的C++网络编程库，提供了异步的、事件驱动的网络编程接口。它支持TCP、UDP和其他网络协议，提供了高度可扩展的网络应用程序开发框架。
4. WebSocket：WebSocket是一种基于TCP的协议，用于实现双向通信。C++中有一些库（如WebSocket++和uWebSockets），可用于在C++应用程序中实现WebSocket通信，适用于实时聊天、推送服务等场景。
5. RESTful API：使用C++进行网络编程时，可以创建RESTful API，用于提供Web服务和数据交互。可以使用框架如cpprestsdk（Casablanca）或Pistache来简化RESTful API的开发。
6. 序列化和反序列化：在网络通信中，需要将数据转换为字节流进行传输。C++中可以使用不同的序列化库，如Protocol Buffers、MessagePack或JSONcpp，将对象序列化为字节流，然后在网络中进行传输。

C++网络编程可以利用C++语言的性能和灵活性，在网络应用程序开发中提供强大的功能和控制。然而，网络编程需要处理网络协议、并发、错误处理等复杂的问题，需要仔细处理和测试。

交换机（Switch）和路由器（Router）是计算机网络中常用的两种网络设备，它们在网络中起着不同的作用。

交换机（Switch）是一种用于局域网（LAN）的网络设备。它通过物理地址（MAC地址）来转发数据包，它能够在网络中根据MAC地址进行数据包的转发和交换。当交换机接收到一个数据包时，它会查看数据包中的目标MAC地址，并将数据包转发到与目标地址相关联的端口上。这样，交换机能够实现快速、可靠的数据包传输，提高局域网内部的通信效率。

路由器（Router）是一种用于广域网（WAN）或互联网的网络设备。它通过IP地址来转发数据包，它能够在网络中根据IP地址进行数据包的转发和路由选择。当路由器接收到一个数据包时，它会查看数据包中的目标IP地址，并根据路由表确定下一跳的路由器，并将数据包转发到相应的接口上。这样，路由器能够连接多个网络，并根据网络之间的距离和优先级选择最佳路径进行数据包传输，实现网络之间的通信。

总结：

- 交换机主要用于局域网内部，根据MAC地址进行数据包的转发和交换。
- 路由器主要用于广域网或互联网，根据IP地址进行数据包的转发和路由选择。
- 交换机提供快速、可靠的局域网内部通信。
- 路由器连接多个网络，并负责网络之间的数据包传输和路由选择。
- 在复杂的网络中，通常会同时使用交换机和路由器来构建高效的网络架构。 

## IP

在计算机网络编程中，"IP"通常指的是互联网协议（Internet Protocol）。互联网协议是一种用于在网络中传输数据的协议。它定义了数据在网络中的传输方式和地址分配规则。

IP地址是互联网协议中用于标识和定位设备的地址。IP地址由一系列数字组成，常见的是IPv4（Internet Protocol version 4）和IPv6（Internet Protocol version 6）。IPv4地址由32位二进制数字表示，例如"192.168.0.1"；而IPv6地址由128位二进制数字表示，例如"2001:0db8:85a3:0000:0000:8a2e:0370:7334"。

在计算机网络编程中，使用IP地址来标识网络中的设备，以便进行数据的发送和接收。通过IP地址，计算机可以确定数据的源和目的地，并将数据包正确地路由到目标设备。

此外，IP还定义了一些与网络通信相关的协议，例如TCP（Transmission Control Protocol）和UDP（User Datagram Protocol）。这些协议建立在IP协议之上，提供可靠的数据传输和其他网络通信功能。因此，在计算机网络编程中，IP通常是指互联网协议及其相关的地址和协议。

IPv4（Internet Protocol version 4）是目前广泛使用的互联网协议之一。它是互联网通信中的基础协议，用于将数据包从一个设备传输到另一个设备。

IPv4使用32位二进制地址来标识网络上的设备。这些地址由四个8位组成，每个组使用十进制表示，用点分十进制（dotted-decimal）表示法表示，例如192.168.0.1。IPv4地址空间总共有约42亿个可能的地址，但由于地址需求的增长，IPv4地址已经逐渐短缺。

IPv4地址通常分为两部分：网络地址和主机地址。网络地址用于标识设备所在的网络，主机地址用于标识设备在该网络中的具体位置。通过将网络地址和主机地址结合起来，可以唯一地标识一个设备在互联网中的位置。

除了地址，IPv4还定义了一些其他重要的概念和协议，其中包括：

1. 子网掩码（Subnet Mask）：用于划分网络地址和主机地址的边界。子网掩码确定了哪些位用于网络地址，哪些位用于主机地址。
2. 默认网关（Default Gateway）：它是网络中的一个设备，用于在不同网络之间进行数据转发。默认网关通常是本地网络中的路由器。
3. DNS（Domain Name System）：它将人类可读的域名（如example.com）映射到对应的IP地址。通过DNS，用户可以使用易于记忆的域名来访问互联网上的资源，而无需记住复杂的IP地址。
4. DHCP（Dynamic Host Configuration Protocol）：它是一种用于自动分配IP地址和其他网络配置信息的协议。通过DHCP，设备可以动态获取可用的IPv4地址，而无需手动配置。

IPv4的主要限制是地址空间有限。由于IPv4地址的短缺，为了满足不断增长的网络需求，出现了IPv6（Internet Protocol version 6）作为其后继协议。IPv6采用128位地址空间，提供了远远超过IPv4的地址数量，以应对未来互联网的需求。然而，IPv4仍然在许多网络中广泛使用，并且与IPv6共存，以确保互联网的连通性。

127.0.0.1是IPv4中的一个特殊IP地址，被称为"回环地址"（Loopback Address）。它是用于本地主机（即自己的计算机）的通信而保留的地址。

当一个程序尝试通过网络协议访问127.0.0.1时，数据包将被发送到本地网络接口，然后立即返回，仿佛是从网络中的另一个设备发送的一样。这使得程序可以与自己的计算机进行通信，用于测试和调试网络应用程序，而无需连接到真实的网络。

通常情况下，当在计算机上输入"[http://127.0.0.1"或"localhost"时，将访问本地计算机上的网络服务或应用程序。例如，访问本地的Web服务器可以使用"http://127.0.0.1"或"http://localhost"。](http://127.0.0.xn--1""localhost"%2C-uk45au88d34x5q0ax8nydz41iua678zjihn1a3mx630b6wjf74acwl6o3a91ddo3nh8a629y.xn--%2Cweb"http-6u0rs6dwew70cyhfptmzpdo2okj2eqsas57vosg111lfh6b//127.0.0.1"或"http://localhost"。)

总结起来，127.0.0.1是IPv4中用于本地主机回环测试的特殊地址，可以访问本地计算机上运行的服务和应用程序。

## TCP连接简介

### 什么是TCP协议

在此之前，需要了解网络的协议层模型。这里不使用OSI七层模型，而是直接通过**网际网协议族**进行讲解。

在网际网协议族中，协议层从上往下如下图所示：

<img src="/home/suyu/.config/Typora/typora-user-images/image-20230623212344298.png" alt="image-20230623212344298" style="zoom: 50%;" />

这个协议层所表示的意义为：如果A机和B机的网络都是使用（或可以看作是）网际网协议族的话，那么从机子A上发送数据到机子B所经过的路线大致为：

A的应用层→A的传输层（TCP/UDP）→A的网络层（IPv4，IPv6）→A的底层硬件（此时已经转化为物理信号了）→B的底层硬件→B的网络层→B的传输层→B的应用层

而我们在使用socket（也就是套接字）编程的时候，其实际上便是工作于应用层和传输层之间，此时我们可以屏蔽掉底层细节，将网络传输简化为：

A的应用层→A的传输层→B的传输层→B的应用层

而如果使用的是TCP连接的socket连接的话，每个数据包的发送的过程大致为：

- 数据通过socket套接字构造符合TCP协议的数据包
- 在屏蔽底层协议的情况下，可以理解为TCP层直接将该数据包发往目标机器的TCP层
- 目标机器解包得到数据

其实不单是TCP，其他协议的**单个数据**发送过程大致也是如此。

TCP协议和与其处在同一层的UDP协议的区别主要在于其对于**连接和应用层数据的处理和发送方式**。

如上一节所述，要使用TCP连接收发数据需要做三件事：

- 建立连接
- 收发数据
- 断开连接

下面将对这三点展开说明：

### 建立连接：TCP的三次握手

> SYN（Synchronize）
>
> ACK（Acknowledgment）
>
> FIN（Finish）

在没进行连接的情况下，客户端的TCP状态处于`CLOSED`状态，服务端的TCP处于`CLOSED`（未开启监听）或者`LISTEN`（开启监听）状态。

TCP中，服务端与客户端建立连接的过程如下：

- 客户端主动发起连接（在socket编程中则为调用`connect`函数），此时客户端向服务端发送一个SYN包
- 这个SYN包可以看作是一个小数据包，不过其中没有任何实际数据，仅有诸如TCP首部和TCP选项等协议包必须数据。可以看作是客户端给服务端发送的一个信号
- 此时客户端状态从`CLOSED`切换为`SYN_SENT`
- 服务端收到SYN包，并返回一个针对该SYN包的响应包（ACK包）和一个新的SYN包。
- 在socket编程中，服务端能收到SYN包的前提是，服务端已经调用过`listen`函数使其处于监听状态（也就是说，其必须处于`LISTEN`状态），并且处于`accept`函数等待连接的阻塞状态。
- 此时服务端状态从`LISTEN`切换为`SYN_RCVD`
- 客户端收到服务端发来的两个包，并返回针对新的SYN包的ACK包。
- 此时客户端状态从`SYN_SENT`切换至`ESTABLISHED`，该状态表示可以传输数据了。
- 服务端收到ACK包，成功建立连接，`accept`函数返回出客户端套接字。
- 此时服务端状态从`SYN_RCVD`切换至`ESTABLISHED`

当连接建立之后，就可以通过客户端套接字进行收发数据了。 

> 以下是TCP三次握手的步骤：
>
> 1. **第一步（SYN）**：客户端发送一个带有SYN（Synchronize）标志的数据包到服务器。这个数据包包含客户端的初始序列号（ISN），表示客户端准备建立连接。
> 2. **第二步（SYN-ACK）**：服务器收到客户端的SYN包后，会发送一个带有SYN和ACK（Acknowledgment）标志的数据包作为回应。该数据包确认客户端的初始序列号，并将服务器的初始序列号作为回应发送给客户端。
> 3. **第三步（ACK）**：客户端收到服务器的SYN-ACK包后，会发送一个带有ACK标志的数据包作为最后的确认。这个ACK包确认服务器的初始序列号，同时也表示客户端准备好进行数据传输。
>
> 在完成这三个步骤后，TCP连接就建立起来了，双方可以开始进行可靠的双向通信。现在客户端和服务器都知道对方的初始序列号，并且可以使用这些序列号来分段和重组数据，以确保数据的正确传输。
>
> TCP三次握手的目的是确保双方都同意建立连接，并且双方都能够正确地接收和发送数据。通过这个过程，双方可以交换必要的信息，建立起可靠的通信通道，以满足数据传输的要求。

### 断开连接：TCP四次挥手

在收发数据之后，如果需要断开连接，则断开连接的过程如下：

- 双方中有一方（假设为A，另一方为B）主动关闭连接（调用`close`，或者其进程本身被终止等情况），则其向B发送FIN包
- 此时A从`ESTABLISHED`状态切换为`FIN_WAIT_1`状态
- B接收到FIN包，并发送ACK包
- 此时B从`ESTABLISHED`状态切换为`CLOSE_WAIT`状态
- A接收到ACK包
- 此时A从`FIN_WAIT_1`状态切换为`FIN_WAIT_2`状态
- 一段时间后，B调用自身的`close`函数，发送FIN包
- 此时B从`CLOSE_WAIT`状态切换为`LAST_ACK`状态
- A接收到FIN包，并发送ACK包
- 此时A从`FIN_WAIT_2`状态切换为`TIME_WAIT`状态
- B接收到ACK包，关闭连接
- 此时B从`LAST_ACK`状态切换为`CLOSED`状态
- A等待一段时间（两倍的最长生命周期）后，关闭连接
- 此时A从`TIME_WAIT`状态切换为`CLOSED`状态

> FIN（Finish）包是TCP（Transmission Control Protocol）中的一种控制包，用于关闭TCP连接的过程。
>
> 当一方决定关闭连接时，它会发送一个带有FIN标志的TCP数据包，称为FIN包。发送FIN包的一方通知对方自己不再发送数据，并且希望关闭连接。
>
> 以下是TCP连接关闭的过程：
>
> 1. 第一步（发送FIN）：当一方决定关闭连接时，它发送一个带有FIN标志的TCP数据包给对方。这个FIN包表示发送方不再发送数据，但仍然愿意接收对方发送的数据。
> 2. 第二步（收到FIN）：接收方收到FIN包后，会向发送方发送一个确认ACK（Acknowledgment）包，确认收到了FIN包。
> 3. 第三步（发送FIN）：如果接收方也希望关闭连接，它可以在确认ACK包的同时发送一个带有FIN标志的数据包给发送方，表示它也不再发送数据。
> 4. 第四步（收到ACK）：发送方收到接收方的FIN包后，发送一个确认ACK包给接收方，表示已经收到了接收方的FIN包。
>
> 通过这个过程，双方可以相互通知彼此关闭连接。当双方都发送了FIN包并收到了对方的ACK包后，TCP连接就成功关闭了。
>
> 需要注意的是，TCP连接的关闭过程是双向的。每一方都可以独立地发送FIN包来关闭连接，而不一定需要等待对方先关闭。这使得TCP连接的关闭过程更加灵活，可以适应双方的需求。
>
> 通过发送FIN包和接收对应的ACK包，TCP连接可以按照可靠的方式关闭，确保双方都能够正确地结束连接并释放相关的资源。


Berkeley Sockets API是一组用于网络编程的应用程序接口（API），最初由伯克利大学开发。它提供了在计算机网络中进行数据通信的标准方法，被广泛用于Unix-like操作系统上的网络编程。

Berkeley Sockets API的设计目标是提供一种通用的编程接口，使开发人员能够创建和管理网络连接，并进行数据的发送和接收。它定义了一系列函数和数据结构，允许应用程序与网络协议栈进行交互。

使用Berkeley Sockets API，开发人员可以执行以下操作：

1. 创建套接字（Socket）：套接字是网络编程中的一个抽象概念，代表一个通信端点。通过调用相应的函数，开发人员可以创建不同类型（如TCP或UDP）的套接字，并指定相应的协议和地址族。
2. 绑定（Bind）和监听（Listen）：应用程序可以将套接字与特定的IP地址和端口号绑定，以便接受传入的连接请求。监听函数可以设置套接字为监听状态，以便接受客户端的连接。
3. 连接（Connect）和接受连接（Accept）：客户端可以使用Connect函数与服务器建立连接。服务器端可以使用Accept函数接受客户端的连接请求，并创建新的套接字与客户端通信。
4. 发送（Send）和接收（Receive）数据：开发人员可以使用Send函数向远程主机发送数据，使用Receive函数接收远程主机发送的数据。这些函数提供了对数据的发送和接收控制。
5. 关闭连接（Close）：通过调用Close函数，开发人员可以关闭套接字并终止连接。

Berkeley Sockets API是一种非常灵活和强大的网络编程接口，被广泛应用于各种编程语言和操作系统上。它为开发人员提供了高层次的抽象，使他们能够轻松地进行网络通信和应用程序开发。

## 网络编程的基本流程

网络编程的基本流程对于服务器是这样的

### 服务器

1. socket：创建socket对象
2. bind：绑定本机ip+port
3. listen：监听来电，若监听到来电，则建立起连接
4. accept：再创建一个socket对象给其发消息，原因是现实中服务器都是面对多个客户端，那么为了区分各个客户端，则对每个客户端都需再分配一个socket对象进行收发消息
5. read，write：收发消息

### 客户端

1. socket：创建socket对象
2. connect：创建服务器ip+port，发起连接请求
3. write，read：建立连接后，就可发收消息

![image-20230622221859458](/home/suyu/.config/Typora/typora-user-images/image-20230622221859458.png)