# 内存序

## 抽象机和内存序

所有的高级通用程序语言都是基于特定的 **abstract machine（抽象机）**进行定义的。可以将 abstract machine 想象为可以直接执行对应的语言的源代码的通用计算机。从 abstract machine 的角度来说，编译器的任务则是将语言源代码翻译为一组真实的计算机能够识别并执行的指令序列，这组指令序列能够在真实的计算机上模拟出当 abstract machine 直接执行源代码时的行为。程序语言的设计关注 abstract machine 的行为，程序语言的实现则关注语言编译器和运行时支持库的行为。

C++11 标准为 C++ abstract machine 引入了` Thread of Execution（ToE`） 的概念。C++ abstract machine 的 ToE 的概念与我们熟知的真实计算机的线程的概念几乎完全一致：一个 ToE 是一个能够独立于其他 ToE 而进行的程序控制流，并且同一个程序的所有 ToE 有访问程序中所有对象的能力。

C++ 是除 C 外最靠近硬件的高级程序语言。因此，C++ 的 abstract machine 并没有完全屏蔽底层实现上需要考虑的细节。Memory order 便是一个因为底层硬件限制而引入到 C++ abstract machine 的一个特性。为了理解 memory order 的设计动机，我们不妨先看一个例子：

```cpp
// Both a and b are initialized to 0.
int a;
int b;

// Thread 1
b = 10;
a = 1;

// Thread 2
while (a != 1)
  ; // Wait until a becomes 1
int c = b;
printf("%d\n", c);
```

在上述的例子中，程序中包含两个全局变量 `a` 和 `b`，可以同时被两个线程所访问；线程 1 首先将 `b` 置为 10，然后将 `a` 置为 1；线程 2 在一个“自旋锁”中等待 `a == 1` 这个条件为真，然后读出 `b` 的值并输出。请大家思考两个问题：

1. 线程 2 中的自旋锁能否退出？
2. 如果线程 2 中的自旋锁确实退出，那么线程 2 输出的值是否为 10？

第二个看起来更加愚蠢的问题则与 memory order 的设计动机紧密相关。在线程 2 退出自旋锁后，线程 2 紧接着读取 `b` 的值，读到的值难道会不为 10 吗？其实这是完全有可能的。原因有如下几点：

- **编译器可能会重排线程 1 中的两条语句**，使得线程 1 首先对 `a` 赋值，然后再对 `b` 赋值。如果此时线程 2 在线程 1 对 `b` 赋值前运行，则线程 2 输出的 `b` 的值将是 `b` 的初始值；
- **CPU 乱序执行可能会重排线程 1 中的两次写操作**，然后以与上一条同样的原理使线程 2 读到错误的值；
- 编译器和 CPU 乱序执行都可能会重排线程 2 中的语句，使得对 `b` 的读取操作早于 `while` 循环发生；
- 存储器在硬件设计上导致了线程 1 看到的内存操作顺序和线程 2 看到的内存操作顺序不同。线程 1 看到的自己的内存操作顺序是 `b=10` 然后 `a=1`，但线程 2 看到的线程 1 的内存操作顺序是 `a=1` 然后 `b=10`。

那么如何保证线程 2 在退出自旋锁后一定会输出 10？这时就需要 memory order 。

## Memory Order

Memory order 最根本的设计动机是**规定一个线程中的写操作何时能够被其他线程看见**。

> 注意这里的用词是“**写操作**”而不是“原子写操作”。

由于 memory order 涉及到多个线程，因此 memory order 是围绕一些关键的 *线程同步节点* 进行定义的，这些关键的线程同步节点就是原子访问操作以及获取释放锁操作。

具体地来说，memory order 以**不同的粒度**规定了，如**果线程 A 和线程 B 通过某个原子变量或者锁建立了线程同步关系，那么其中一个线程在线程同步节点之前的全部或某些写操作必须能够被另一个线程在线程同步节点之后的读操作看到**。这里的“粒度”是指线程同步节点之前的写操作 *有多少* 能够被其他线程看到，以及线程同步节点之后的读操作能够看到多少其他线程写入的值。

```cpp
// Both a and b are initialized to 0.
int a;
int b;

// Thread 1
b = 10;
a = 1;

// Thread 2
while (a != 1)
  ; // Wait until a becomes 1
int c = b;
printf("%d\n", c);
```

我们在线程 1 中有一个原子写操作，在线程 2 中有一个原子读操作。**这两个操作都是线程同步节点，且是对同一个原子变量的操作**，因此线程 1 和线程 2 建立了线程同步关系。我们希望分别为这两个原子操作指派一个 memory order，使得：

1. 对于线程 1，我希望在对 `a` 的原子写操作结束后，在源程序中排在对 `a` 赋值之前的对 `b` 的（非原子）写操作能保证被线程 2 所看到；
2. 对于线程 2，我希望在对 `a` 的原子读操作结束且发现读到的值为线程 1 写入的值之后，我能够看到线程 1 在写入 `a` 之前的写操作。也就是说，我希望能够看到 `b` 确实被线程 1 写入了 10，即线程 2 确实能输出 10。

按照粒度和原子操作类型（读或写）进行划分，C++11 规定了六种不同的 memory order，定义在 `std::memory_order` 枚举中：

1. Relaxed，定义为 `std::memory_order_relaxed`；
2. Consume，定义为 `std::memory_order_consume`；
3. Acquire，定义为 `std::memory_order_acquire`；
4. Release，定义为 `std::memory_order_release`；
5. Acquire-Release，定义为 `std::memory_order_acq_rel`；
6. Sequential Consistent，定义为 `std::memory_order_seq_cst`。

在执行原子操作时，可以传入一个 `std::memory_order` 枚举，指明这个原子操作需要满足的 memory order。如果没有传入 `std::memory_order`，则默认的 memory order 为 Sequential Consistent。例如，上一节中改造后的代码片段中，对 `a` 的 `store` 和 `load` 操作均满足 sequential consistent 这一 memory order。

### Relaxed

Relaxed 是最弱的 memory order。事实上，relaxed 应该称为“没有 memory order”：如果某个原子操作使用 relaxed 作为其 memory order，那么这个原子操作将退化为一个单纯的原子操作，不再具有线程同步节点的作用。即：

1. 在一个 relaxed 写操作之前的写操作将不保证能被其他也执行对同一个原子变量的 relaxed 读操作的线程看到；
2. 在一个 relaxed 读操作之后的读操作也不保证能看到其他对同一个原子变量的 relaxed 写操作之前的写操作。

如果我们将前文中的例子中对 `a` 的 `store` 和 `load` 操作均使用 relaxed 作为 memory order，那么线程 1 将不能保证线程 2 能读到在写 `a` 变量之前对 `b` 的写入，线程 2 也不能保证在退出自旋锁能够读到线程 1 对 `b` 写入的值。

需要注意到的是，即使使用 relaxed 这一最弱的 memory order，原子变量的操作仍然是原子操作，这一事实不因 memory order 的改变而改变。因此，relaxed 非常适合于单纯的、不具有线程同步语义的原子操作，例如对引用计数的原子递增或原子递减。

### Consume

Consume 这一 memory order 仅对原子读操作有效

>  我们首先需要理解一个重要概念：什么是“两个操作之间具有数据依赖”？翻看 C++11 标准可知，对于操作 A 和操作 B，如果操作 A 先于操作 B 发生，则有三种情况会使得操作 B *数据依赖于* 操作 A：
>
> 1. 操作 B 有一个操作数用到了操作 A 的结果；（有特殊情况，参见 C++ 标准或 [cppreference](https://en.cppreference.com/w/cpp/atomic/memory_order)）；
> 2. 操作 A 向某个标量对象 M 写入了值，操作 B 从 M 中读出了值；
> 3. 存在第三个操作 X 数据依赖于操作 A，操作 B 又数据依赖于操作 X。

在前文的例子中，线程 1 中对 `a` 的原子写操作并不数据依赖于对 `b` 的写操作。但是，如果将线程 1 的代码更改为如下形式，则对 `a` 的原子写操作依赖于对 `b` 的写操作：

```cpp
// Thread 1
b = 1;
a.store(b);
```

我们令 `store` 操作为 release 操作、令 `load` 操作为 consume 操作，代码如上述修改后所示，即线程 1 中对 `a` 的原子写数据依赖于对 `b` 的写操作，那么线程 2 将保证能够读到线程 1 向 `b` 写入的值。

```cpp
// Both a and b are initialized to 0.
int a;
int b;

// Thread 1
b = 10;
a.store(b,std::memory_release);

// Thread 2
while (a.load(std::memory_order_conusme) != 1)
  ; // Wait until a becomes 1
int c = b;
printf("%d\n", c);
```

### Acquire

Acquire 这一 memory order 仅对原子读操作有效。**Acquire 与 consume 唯一的区别是 acquire 要求线程 B 能够看到线程 A 中在 release 操作之前的所有写操作，而不仅仅是与写原子变量具有数据依赖关系的写操作。**因此，如果我们令线程 1 中对 `a` 的原子写操作为 release 操作、令线程 2 中对 `a` 的原子读操作为 acquire 操作，则线程 2 将保证读到线程 1 中对 `b` 写入的值。

```cpp
// Both a and b are initialized to 0.
int a;
int b;

// Thread 1
b = 10;
a.store(b,std::memory_order_ release );

// Thread 2
while (a.load(std::memory_order_acquire) != 1)
  ; // Wait until a becomes 1
int c = b;
printf("%d\n", c);
```

### Release

Release 这一 memory order 仅对原子写操作有效。Release 操作通常是与 consume 或 acquire 操作配对的。当某个线程执行 release 操作后，其他对同一原子变量执行 consume 或 acquire 操作的线程将以相应的粒度看到该线程 release 操作之前的写操作。

### Acquire-Release

在一个原子操作内可能既有读操作也有写操作，例如原子性的 compare-and-swap 操作和原子性的 read-modify-write 操作。Acquire-Release 这一 memory order 则指明了这样的原子操作将既是一个 acquire 操作、也是一个 release 操作。

### Sequential Consistent

Sequential Consistent 是最强的 memory order。这个 memory order 规定：

1. 对于一个原子读操作，该操作都是 acquire 操作；
2. 对于一个原子写操作，该操作是 release 操作；
3. 对于一个既有读又有写的原子操作，该操作既是 acquire 操作也是 release 操作；
4. **程序内所有线程在使用 sequential consistent 这一 memory order 操作原子变量时，必须以一致的顺序看到程序内的所有 sequential consistent 操作**

```cpp
std::atomic<int> x;
std::atomic<int> y;
std::atomic<int> z;

constexpr static const auto seq_cst = std::memory_order_seq_cst;
constexpr static const auto relaxed = std::memory_order_relaxed;

int main() {
  std::thread a([]() { x.store(1, seq_cst); });
  std::thread b([]() { y.store(1, seq_cst); });
  std::thread c([]() {
    while (x.load(seq_cst) != 1)
      ; // Wait while x becomes 1
    if (y.load(seq_cst) == 1) {
      z.fetch_add(1, relaxed);
    }
  });
  std::thread d([]() {
    while (y.load(seq_cst) != 1)
      ; // Wait while y becomes 1
    if (x.load(seq_cst) == 1) {
      z.fetch_add(1, relaxed);
    }
  });

  a.join();
  b.join();
  c.join();
  d.join();

  // Can this assertion fail?
  assert(z.load(relaxed) != 0);

  return 0;
}
```

上述示例程序启动了四个线程，分别进行如下的工作：

1. 线程 `a` 使用 sequential consistent 这一 memory order 向 `x` 中原子写入值 1；
2. 线程 `b` 使用 sequential consistent 这一 memory order 向 `y` 中原子写入值 1；
3. 线程 `c` 首先自旋等待 `x` 被置为 1，然后检查 `y` 的值；若 `y` 也被置为 1，则递增 `z` 计数器；
4. 线程 `d` 首先自旋等待 `y` 被置为 1，然后检查 `x` 的值；若 `x` 也被置为 1，则递增 `z` 计数器。

Sequential consistent 的作用则在这个例子中体现出来了。同一个程序中，所有的线程在执行 sequential consistent 操作时，各个线程将观察到一致的 sequential consistent 操作顺序。上面所说的情况则不会存在：不会有一个线程观察到的操作顺序是 `x=1` 然后 `y=1`，而另一个线程观察到的操作顺序是 `y=1` 然后 `x=1`。因此，在上述的示例程序中， `main` 函数中的 `assert` 检查将永不失败。