# 性能调试

## Perf

> 事件类型：
>
> - 硬件
> - 软件
>   - 预定义事件
>   - 自定义事件
>   - eBPF
>
> 事件内容：
>
> - 寄存器（IP）
> - 堆栈（用户、内核、堆栈内存dump）
> - Last Branch Record
> - 时间，线程ID，进程ID
>
> 事件收集
>
> - 周期
> - 收集内容
> - RingBuffer大小，覆盖方式
> - PMU时分复用（group）

事件处理

| 命令   | 含义                         |
| ------ | ---------------------------- |
| record | 记录到文件perf.data          |
| report | 读取perf.data并以CUI方式展现 |
| stat   | 统计事件个数                 |
| script | 脚本自定义处理               |
| trace  | live输出事件（strace）       |
| probe  | 自定义软件事件               |
| top    | 类似top命令                  |
| list   | 列出事件                     |

Perf 是用来进行软件性能分析的工具,可以利用 PMU，tracepoint 和内核中的特殊计数器来进行性能统计,用来分析内核和应用程序的性能。
perf可以完成如下的性能分析

- 计算每个时钟周期内的指令数 进行函数级别的采样
- 了解性能瓶颈 替代strace
- **添加动态内核 probe 点**
- 做 benchmark 衡量调度器的好坏

perf性能分析需要了解如下背景知识

- cache 流水线
- 超标量体系结构
- 乱序执行
- 分支预测
- PMU计数
- tracepoint

## perf的基本使用方法

[perf Examples](https://www.brendangregg.com/perf.html)

### perf list

```shell
perf list 
```

列出所有能够触发 perf 采样点的事件,主要区分为如下三类事件：

<img src="https://img-blog.csdnimg.cn/20201028143556359.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phc29uYWN0aW9ucw==,size_16,color_FFFFFF,t_70#pic_center" alt="img" style="zoom: 67%;" />

- Hardware Event 是由 PMU 硬件产生的事件，比如 cache 命中
- Software Event 是内核软件产生的事件，比如进程切换，tick 数等
- Tracepoint event 是内核中的静态 tracepoint 所触发的事件

### perf stat

```shell
perf stat ./demo
```

通过概括精简的方式提供被调试程序运行的整体情况和汇总数据

[perf stat输出解读](http://zhengheng.me/2015/11/12/perf-stat/)

![img](https://img-blog.csdnimg.cn/20201028143704313.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phc29uYWN0aW9ucw==,size_16,color_FFFFFF,t_70#pic_center)

- Task-clock-msecs：CPU 利用率，**该值高，说明程序的多数时间花费在 CPU 计算上**而非 IO（输入输出）。
- Context-switches：进程切换次数，记录了程序运行过程中发生了多少次进程切换，频繁的进程切换是应该避免的。
- Cache-misses：程序运行过程中总体的 cache 利用情况，如果该值过高，说明程序的 cache 利用不好
- CPU-migrations：表示进程 t1 运行过程中发生了多少次 CPU 迁移，即被调度器从一个CPU 转移到另外一个 CPU 上运行。
- Cycles：处理器时钟，一条机器指令可能需要多个 cycles，
- Instructions: 机器指令数目。
- IPC：是 Instructions/Cycles 的比值，**该值越大越好，说明程序充分利用了处理器的特性**。
- Cache-references: cache 命中的次数
- Cache-misses: cache 失效的次数。
  注：通过指定 -e 选项，您可以改变 perf stat 的缺省事件

### perf top

用于实时显示当前系统的性能统计信息。该命令主要用来观察整个系统当前的状态，比如可以通过查看该命令的输出来查看当前系统最耗时的内核函数或某个用户进程

```shell
perf top
```

### perf -e

如果想关心perf的具体某个事件，希望按某个事件来进行统计则可以通过-e来指定某个事件
使用 tracepoint 的基本需求是对内核的运行时行为的关心

```cpp
perf stat -e raw_syscalls:sys_enter ls 
```

列出系统调用的次数

<img src="https://img-blog.csdnimg.cn/20201028150627582.png#pic_center" alt="在这里插入图片描述" style="zoom:50%;" />

```shell
perf record -e raw_syscalls:sys_enter ls
perf report
```

查看系统调用主要发生在哪里

<img src="https://img-blog.csdnimg.cn/20201028150728409.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phc29uYWN0aW9ucw==,size_16,color_FFFFFF,t_70#pic_center" alt="img" style="zoom: 67%;" />

### perf record/perf report

perf record 记录单个函数级别的统计信息，并使用 perf report 来显示统计结果

```shell
perf record -e cpu-clock ./t1
perf report

sudo perf record -e cpu-clock -g -p 2548
```

- -g 选项是告诉perf record额外记录函数的调用关系

- -e cpu-clock 指perf record监控的指标为cpu周期

- -p 指定需要record的进程pid

```cpp
$ sudo perf report -n --stdio
//统计每个调用栈出现的百分比，然后从高到低排列。
```

> #### 生成火焰图
>
> ```shell
> #生成折叠后的调用栈
> perf script -i perf.data > perf.unfold
> #用stackcollapse-perf.pl 将 perf.unfold 中的符号进行折叠：
> ../FlameGraph/stackcollapse-perf.pl perf.unfold > perf.floded
> #生成 svg 图
> ../FlameGraph/flamegraph.pl perf.floded > perf.svg
> #使用谷歌浏览器打开火焰图
> google-chrome perf.svg
> ```
>
> **互动性**
> 火焰图因为是 svg 图片，可以与用户互动：
>
> - 鼠标悬浮。火焰每一层都会标注函数名，鼠标悬浮时会显示完整的函数名、抽样抽中的次数、占据总抽样次数的百分比。
>
> - 点击放大。在某一层点击，火焰图会水平放大，该层会占据所有宽度，显示详细信息。左上角会同时显示“Reset Zoom”，点击该链接，图片就会恢复原样。
>
> - 搜索。按下 Ctrl + F 会显示一个搜索框，用户可以输入关键词或正则表达式，所有符合条件的函数名会高亮显示。
>
> **局限性**
>
> 当出现这两种情况下，无法画出火焰图，需要修正系统行为。
>
> - 调用栈不完整。当调用栈过深时，某些系统只返回前面的一部分（比如前10层）。
> - 函数名缺失。有些函数没有名字，编译器只用内存地址来表示（比如匿名函数）。有可能是因为编译器优化等级太高。
>
> ![img](https://img-blog.csdnimg.cn/20200616142406904.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B3bDk5OQ==,size_16,color_FFFFFF,t_70)
>
> 火焰图中的每一个方框是一个函数，方框的长度，代表了它的执行时间，所以越宽的函数，执行越久。火焰图的楼层每高一层，就是更深一级的函数被调用，最顶层的函数，是叶子函数。
>
> 火焰图是基于 stack 信息生成的 SVG 图片, 用来展示 CPU 的调用栈。
>
> - y 轴表示调用栈, 每一层都是一个函数. 调用栈越深, 火焰就越高, 顶部就是正在执行的函数, 下方都是它的父函数.
>
> - x 轴表示抽样数, 如果一个函数在 x 轴占据的宽度越宽, 就表示它被抽到的次数多, 即执行的时间长. 注意, x 轴不代表时间, 而是所有的调用栈合并后, 按字母顺序排列的.
>
> #### 生成红蓝差分火焰图
>
> 在某些情况下我们关心的是加上某项功能后，性能的对比情况。这种情况下需要用到差分火焰图来进行分析：
>
> ```；shell
> $ sudo perf record -g -F 99 -- cp -r ~/bbb/ ./bbb.test
> $ sudo perf script -i perf.data > out1.perf
> $ ../FlameGraph/stackcollapse-perf.pl out1.perf > out1.floded
> $ ../FlameGraph/flamegraph.pl out1.floded > cp1.svg
> $ ../FlameGraph/difffolded.pl out.floded  out1.floded > diff1.floded
> $ 
> $ ../FlameGraph/flamegraph.pl --negate diff1.floded > diff1.svg
> 
> ```
>
> ![img](https://img-blog.csdnimg.cn/20200616142426499.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B3bDk5OQ==,size_16,color_FFFFFF,t_70)
>
> 在对比新旧数据，使用对比结果给`cp.svg`重新上色：
>
> ```shell
> $ ../FlameGraph/difffolded.pl out.floded  out1.floded > diff1.floded
> $ 
> $ ../FlameGraph/flamegraph.pl --negate diff1.floded > diff1.svg
> ```
>
> 而在红/蓝差分火焰图中, 使用不同的颜色来表示两个文件中的差异部分。红色表示增长, 蓝色表示衰减：
>
> ![img](https://img-blog.csdnimg.cn/20200616142443277.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B3bDk5OQ==,size_16,color_FFFFFF,t_70)

### perf probe

[perf probe](https://blog.csdn.net/qq_38349235/article/details/126143881?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167500182416800184152424%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=167500182416800184152424&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-126143881-null-null.142^v71^control,201^v4^add_ask&utm_term=perf%20probe&spm=1018.2226.3001.4187)

能够动态地在想查看的地方插入动态监测点

```shell
perf probe schedule:12 cpu
```

上例利用 probe 命令在内核函数 schedule() 的第 12 行处加入了一个动态 probe 点，和 tracepoint 的功能一样，内核一旦运行到该 probe 点时，便会通知 perf。可以理解为动态增加了一个新的 tracepoint



### perf sched

perf sched提供了许多工具来分析内核CPU调度器的行为。你可以用它来识别和量化调度器延迟的问题。

```sleep
perf sched record sleep 10
perf sched latency --sort max
```

![img](https://img-blog.csdnimg.cn/20201028150759848.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phc29uYWN0aW9ucw==,size_16,color_FFFFFF,t_70#pic_center)

- Task: 进程的名字和 pid
- Runtime: 实际运行时间
- Switches: 进程切换的次数
- Average delay: 平均的调度延迟
- Maximum delay: 最大延迟，对交互性影响很大

#### perf sched map

```shell
perf sched record sleep 10
perf sched map
```

显示了所有的CPU和上下文切换事件

![img](https://img-blog.csdnimg.cn/20201028150837787.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phc29uYWN0aW9ucw==,size_16,color_FFFFFF,t_70#pic_center)

星号表示调度事件正在发生的CPU。
Map 的好处在于提供了一个的总的视图，将成百上千的调度事件进行总结，显示了系统任务在 CPU 之间的分布，假如有不好的调度迁移，比如一个任务没有被及时迁移到 idle 的 CPU 却被迁移到其他忙碌的 CPU，类似这种调度器的问题可以从 map 的报告中一眼看出来。

#### perf sched script

显示调度相关的事件，可以查看schedule的trace

#### perf sched replay

重放 perf.data 文件中所记录的调度场景。
perf sched replay采集记录的调度器事件，通过生成具有类似运行时间和上下文切换的线程来模拟工作负载。

```shell
perf sched replay -r 1
```

### perf lock

锁是内核同步的方法，一旦加了锁，其他准备加锁的内核执行路径就必须等待，降低了并行。因此对于锁进行专门分析应该是调优的一项重要工作

```shell
perf lock record dd if=/dev/testb_a of=/dev/null
perf lock report
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201028151317566.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phc29uYWN0aW9ucw==,size_16,color_FFFFFF,t_70#pic_center)

- “Name”：锁的名字，比如 md->map_lock，即定义在 dm.c 结构 mapped_device 中的读写锁。
- “acquired”：该锁被直接获得的次数，即没有其他内核路径拥有该锁的情况下得到该锁的次数。
- “contended”：冲突的次数，即在准备获得该锁的时候已经被其他人所拥有的情况的出现次数。
- “total wait”：为了获得该锁，总共的等待时间。
- “max wait”：为了获得该锁，最大的等待时间。
- “min wait”：为了获得该锁，最小的等待时间。

### perf kmem

Perf Kmem 专门收集内核 slab 分配器的相关事件。比如内存分配，释放等。可以用来研究程序在哪里分配了大量内存，或者在什么地方产生碎片之类的和内存管理相关的问题。

![img](https://img-blog.csdnimg.cn/20201028151351306.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phc29uYWN0aW9ucw==,size_16,color_FFFFFF,t_70#pic_center)

该报告有三个部分：

1. 根据 Callsite 显示的部分
   - Callsite： 即内核代码中调用 kmalloc 和 kfree 的地方。比如上图中的函数 `__sigqueue_alloc__`
   - Hit：表示调用kmalloc的次数，为 1表示该函数在 record 期间一共调用了 kmalloc 一次
   - Total_alloc/Per ：显示为 160/160，第一个值 160表示函数 `__sigqueue_alloc`总共分配的内存大小，Per 表示平均值。
   - Frag ：内部碎片的比例。虽然相对于 Buddy System，Slab 正是要解决内部碎片问题，但 slab 依然存在内部碎片，比如一个 cache 的大小为 1024，但需要分配的数据结构大小为 1022，那么有 2 个字节成为碎片。Frag 即碎片的比例。
   - Ping-pong ：是一种现象，在多 CPU 系统中，多个 CPU 共享的内存会出现”乒乓现象”。一个 CPU 分配内存，其他 CPU 可能访问该内存对象，也可能最终由另外一个 CPU 释放该内存对象。而在多 CPU 系统中，L1 cache 是 per CPU 的，CPU2 修改了内存，那么其他的 CPU 的 cache 都必须更新，这对于性能是一个损失。Perf kmem 在 kfree 事件中判断 CPU 号，如果和 kmalloc 时的不同，则视为一次 ping-pong，理想的情况下 ping-pone 越小越好。Ibm developerworks 上有一篇讲述 oprofile 的文章，其中关于 cache 的调优可以作为很好的参考资料。
2. 根据被调用地点显示部分
3. 汇总数据
   显示总的分配的内存和碎片情况，Cross CPU allocation 即 ping-pong 的汇总

> 注：Perf kmem 和 perf lock 实际上都是 perf tracepoint 的特例，您也完全可以用 Perf record > – e kmem:* 或者 perf record – e lock:*> 来完成同样的功能。但重要的是，这些工具在内部对原始数据进行了汇总和分析，因而能够产生信息更加明确更加有用的统计报表。

### perf timechart

perf timechart 的灵感来源于 bootchart。采用“简单”的图形“一目了然”地揭示问题所在。

![img](https://img-blog.csdnimg.cn/20201028151432995.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phc29uYWN0aW9ucw==,size_16,color_FFFFFF,t_70#pic_center)

![img](https://img-blog.csdnimg.cn/20201028151451880.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phc29uYWN0aW9ucw==,size_16,color_FFFFFF,t_70#pic_center)

上图的最上面一行是图例,蓝色表示忙碌，红色表示 idle，灰色表示等待，等等。接下来是 per-cpu 信息,再下面是 per-process 信息.Timechart 可以显示更详细的信息，上图实际上是一个矢量图形 SVG 格式，用 SVG viewer 的放大功能，我们可以将该图的细节部分放大，

### perf script













