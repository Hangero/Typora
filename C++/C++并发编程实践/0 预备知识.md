# 预备知识

## 内存所有权

[C++设计模式由浅入深（三）—— 内存所有权](https://blog.csdn.net/wbvalid/article/details/117852570?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167291794816782427485513%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=167291794816782427485513&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-2-117852570-null-null.142^v70^control,201^v4^add_ask&utm_term=C%2B%2B%E6%89%80%E6%9C%89%E6%9D%83&spm=1018.2226.3001.4187)

> **C++ 里面的对象所有权的关系，指的是谁负责delete谁的关系**。



 **“内存所有权”这则术语的含义是指某个实体需要对其分配的特定内存空间及其生命周期的控制负责**。通常意义上的内存所有权，即我们对驻留在指定内存中的对象生命周期及所有权的管理，本质上就是对象所有权管理的另一种表述方式。内存所有权的概念与资源所有权又是紧密联系在一起的。首先，内存就是一种资源。它不仅仅是程序所能管理的资源，也是到目前位置最广泛使用的资源。其次，C++中管理资源的方式就是管理这个资源所属的对象，也就是我们刚刚提到的，所谓内存所有权的本质。



### 精心设计的内存所有权

#### 只关心内存大小



```cpp
struct MyValues { long a, b, c, d; }
void Reset(MyValues* v) { // 我们不关心v的所有者是谁
	v->a = v->b = v->c = v->d = 0;
}
```

#### 关心是否拥有所有权

##### 独占所有权

当我们获得一个对象的所有权时，通常不需要了解是从谁那里取得的：

```cpp
class A {
public:
	A(std::vector<int>&& v) :v_(std::move(v)) {} // 从随便谁那里取得控制权
private:
	std::vector<int> v_; // 控制权在我手里了
};

```

##### 分享所有权

共享所有权的理念（也即是`std::shared_ptr`通过引用计数表达的思想）也不要求我们知道具体是谁和我们分享了这个对象的所有权：

```cpp
class A {
public:
	A(std::shared_ptr<std::vector<int>> v) : v_(v) {}
	// 不知道也不关心具体是谁分享了v
private:
	std::shared_ptr<std::vector<int>> v_;
	// 通过shared_ptr和其他人分享v的所有权
};

```

总的来说，一个精心设计的内存所有权实践，应当遵顼以下的特征和属性：

- 如果一个函数或者类不以任何方式改变内存所有权，那么客户端和实现者应当明确知情；

- 如果一个函数或者类对传递给他的某些对象获取独占所有权，那么客户端应当明确知情（实

  现者必然知道，因为代码是他写的）；

- 如果一个函数和类会共享传递给他的对象的所有权，那么客户端应（或任何读取客户端代码的人）当明确知情；

- **对于创建的每一个对象，每当被使用时，应当明确调用者是否有义务释放它。**

### 设计糟糕的内存所有权

糟糕的设计需要额外的信息去理解，并无法从上下文中推导出结论。例如，这个`MakeWidget()`函数返回的对象会被谁拥有？

```cpp
Widget* w = MakeWidget();
```

当这个对象不再被需要的时候，是否期望客户端删除它？如果是，那么将要如何删除它？如果我们选择了错误的方式去删除这个对象，那么就有可能造成内存崩溃——例如，这个对象并非由`new`构造，而我们错误地使用了`delete`去删除它。这种情况下最好的结果就是程序崩溃。

```cpp
WidgetFactory WF;
Widget* w = WF.MakeAnother();
```

对于这个工厂对象，它对其创造的对象是否具有所有权？当工厂对象销毁时，它所生产的对象是否也会随之销毁？又或者说，应当由客户端来做这个事？如果我们决定工厂也许知道它所创建的对象，并且会在自己销毁时删除这些对象，但这仍然有发生内存泄露的风险（尤其是当这些被生产出来的对象同时也对其他对象具有所有权）。

```cpp
Widget* w = MakeWidget();
Widget* w1 = Transmogrify(w);
```

函数`Transmogrify(w)`是否会获得对象的所有权呢？在`Transmogrify()`处理后，`w`对象是否仍然存在呢？如果`w1`对象是通过删除`w`对象而构造的，这种情况下我们会得到一个空悬指针`w`；如果对象不被删除，但是我们假设他会被删除，那么就发生了内存泄露。

下面是一个糟糕的内存管理例子，属于治标不治本的典型：

```cpp
void Double(std::shared_ptr<std::vector<int>> v) {
	for (auto& x : *v) {
		x *= 2;
	}
};
...
std::shared_ptr<std::vector<int>> v(...);
Double(v);
...
```

这个`Double()`函数在其接口中声明了对`vector`的共享所有权。然而这个**所有权的分享过于慷慨**，对于`Double()`的而言，它没有理由去拥有它参数的所有权，因为它的目标不是为了延长生命周期，并且他也不会讲所有权转移给其他人，它仅仅是为了修改调用者传给他的`vector`中数据的值。逻辑上说，调用者应当对`vector`具有所有权（或者由调用栈更高层次中的某个对象所拥有），并且`vector`对象在`Double()`调用返回之前应当存活，毕竟是调用者希望我们去处理容器中的元素，假设它在我们处理完之后仍需要用容器做其他的事情。

### C++中表达所有权

- 裸指针或引用：便是不拥有所涉及对象的所有权
- 

#### 表达非所有权

首先，我们从最常见的内存所有权开始：大多数的代码并不进行资源的分配、释放或是对象的构造，析构。这些代码仅仅在别人创建的对象上做一些工作，最后对象会被其他人释放。这种情况下我们如何表达呢？其实很简单，大多数C++程序员都这样做过：

```cpp
void Transmogrify(Widged* w) { // 表示我不会删除对象
...
}
void MustTransmogrify(Widget& w) { // 表示我不会删除对象
...
}
class WidgetProcessor {
public:
	WidgetProcessor(Widget* w) : w_(w) {}
	...
	Widget* w_; // I do not own w
};
```

**非所有权的访问应通过授予裸指针或者引用进行**。是的，即便在C++17的代码中，即使有智能指针的加持，裸指针仍有一席之地。不仅如此，**在整个代码中，大部分的指针都是裸指针，因为它们表达的含义是不拥有所指涉的对象**。

你可能会感到困惑，这个例子中的代码和之前的糟糕实践的代码几乎如出一辙。其实，最主要的区别在于上下文：**在一个优秀的设计中，只有非所有权的访问能够被授予裸指针或引用。实际的所有权往往通过其他的方式表述**。因此，当我们遇到一个裸指针的时候，它所表达的含义就非常清晰，即函数或者类不会乱搞指针所指对象的所有权。当然，这样一来，当我们面对远古代码的时候，可能会感到困惑，因为那里到处都是裸指针。为了清楚起见，建议将这些代码分成几部分进行转换，并在各部分之间明确指出遵循现代准则的转换代码和不遵循现代准则的转换代码。

> 指针或是引用的抉择
>
> 从语法角度看，引用就是一个无法为NULL（或者说nullptr）的指针，并且必须被初始化。一个良好的习惯是，当一个函数接可能接受空指针时，必须对指针判空；如果一个函数不能接受空指针，那么参数中的指针就必须被替换为引用。这是被广泛使用的一个套路，但是并不能认为其是设计模式。也许是认识到了这一点，因此GSL库中提供了一种新式的指针判空方式：not_null<T*>。注意这并不是语言的一部分，但是可以不借助任何语言扩展由标准C++实现。

#### 表示独占所有权

第二种最常见的所有权类型就是独占所有权：代码创造了一个对象，并且负责在后续删除它。删除的任务不会被委派给其他对象，因为独占所有权不允许延长对象的生命周期。这种类型的内存所有权相当常见，以至于我们几乎每时每刻都在使用它：

```cpp
void Work() {
	Widget w;
	Transmogrify(w);
	Draw(w);
}
```

**所有的局部（栈）变量都表达了独占的内存所有权。**注意，这个上下文中的所有权并不意味着其他人不会修改对象。它仅仅意味着，`w`对象的创造者，即`Work()`函数，将会把它删除；删除行为将会成功执行（因为没有其他人删除它）；对象将被事实上删除（在作用域之内没有其他东西试图延长对象的生命周期）。

C++11标准中，提出了另外一种表达独占所有权的方式，它**主要被使用在对象无法被构造在栈上而必须构造柱堆中的场景下**。当所有权需要被共享或者转移的情况下，往往我们会在堆上分配内存空间来存放这些对象。

分配在堆上的情况：

- 更长的生命周期（栈上构造的对象一旦离开其作用域就会被销毁）
- 对象大小在编译时未知（例如，当一个基类指针指向派生类对象的多态场景下）

我们可以通过`std::unique_ptr`来表示这样的独占所有权：

```cpp
class FancyWidget : public Widget { ... };
std::unique_ptr<Widget> w(new FancyWidget);
```

那么，在假定已经获得正确所有权的情况下，我们如何对一个`Widget`对象调用`Transmogrify()`呢？依然是通过裸指针进行：

```cpp
void Transmogrify(Widget* w);
Transmogrify(WidgetFactory());
```

那么对于栈对象又如何呢？栈对象的所有权可以在其被析构前转移至其他人手中吗？这个问题就会有点复杂了，因为对象被分配的内存在栈上，并且将会被释放，所以这种行为或者操作会导致一定程度的复制。究竟多少内容被复制取决于对象是否可移动。这种行为可以被用于返回值，但更常用于向函数传参并允许其获取独占所有权。类似的函数必须声明其参数为右值或者万能引用：

```cpp
void Consume(Widget&& w) { auto my_w = std::move(w); ... }
Widget w, w1;
Consume(std::move(w)); // w将不复存在，因为它进入了“移出”态
Consume(w1); // 无法通过编译，必须满足移动语义
```

注意，调用者必须显式地通过调用`std::move`来放弃对象的所有权。这是这种惯用法的优势之一，如果没有这种操作，调用时发生的所有权的转移看起来就像是普通的调用一样。

#### 表达共享所有权

最后一种还没讲到的所有权表达是共享所有权，即多个实体平等地共享对象。首先，我们高度注意，共享所有权的概念经常被误用，或者滥用。考虑之前的例子，当一个函数被传入了一个共享指针，但是其实它并不需要拥有对象。**这种通过引用计数来防止对象被销毁的做法非常诱人。然而，这通常是糟糕设计的表现**。在大多数系统中，某种程度上说，资源的所有权必须被清晰地反映在资源管理的设计上。这种懒人式设计虽然合法，但是我们要知道，尽管显式销毁对象的行为鲜少发生，但这种行为并不要求共享所有权来实现，通常是通过清晰的表达所有权来实现（专有指针，数据成员，容器都可以做得足够好）。

话虽如此，有些确定的场景下依然需要使用到共享所有权。最常见的合法应用场景是在底层数据结构中，如链表，树型结构等。

在C++中，共享所有权的表达式通过共享指针`std::shared_ptr`进行的：

```cpp
struct ListNode {
	T data;
	std::shared_ptr<ListNode> next, prev;
};
class ListIterator {
	...
	std::shared_ptr<ListNode> node_p;
};
```

这种设计的优势在于，每个链表单元在与其他部分断开后，依然可以通过迭代器访问。这并不是`std::list`的实现方式，并且STL中的链表也不提供类似保证。然而，它可以是某些场景下的合法设计，例如，一个线程安全的链表。注意，在特殊场景下可能会需要使用原子的共享指针，它仅在C++20标准中提供（当然也可以自行造一个C++11版本的轮子）。

那么，**哪些函数应该使用共享指针作为参数呢？**在一个遵循良好内存所有权设计的程序中，这类函数表达了调用者意图获取部分所有权，以使得对象的生存期略长于函数调用，因为共享指针的拷贝会被创建，在函数调用结束时析构。**在并发的场景下，这也意味着函数需要保证对象在函数调用的过程中不会被其他线程析构。**

共享所有权有几个缺点我们需要铭记在心。最为人所熟知的就是**共享指针的灾难，即循环引用**。如果两个对象具有互相指向的共享指针，那么整个体系会永远“被占用”。C++对此的通常解决方案是使用std::weak_ptr。它是一种可以安全指向可能被删除对象的指针。假如刚才的例子采用一个共享指针，一个弱指针的话，那么这种循环依赖关系就会被打破。

循环引用的问题是很现实的，当某些设计中，意图通过共享所有权来隐藏资源所有权不确定的问题时，这种循环引用的隐患往往更严重。然而，共享所有权还有其他的缺点。**一个共享指针的性能通常要比裸指针慢**。而另一方面，专有指针的性能可以和裸指针相当（事实上，`std::unique_ptr`的性能与裸指针一模一样）。因为当一个共享指针对象被创建时，需要额外分配内存空间来存放引用计数。

在C++11中，**`std::make_shared`可以被用来同时分配对象和引用计数的内存空间，但这样就隐含了对象创建出来就是为了被共享的意图**（通常，对象工厂函数返回专有指针，有些再后来被转换为共享指针）。对于共享指针的拷贝或者删除都会增加或减少引用计数。共享指针通常在并发数据结构中更常用，因为在更底层的结构中，所有权确实可能更加模糊。然而，设计一个线程安全的共享指针并不简单，并且也会带来额外的运行时开销。



#### 弱引用

[[When is std::weak_ptr useful?](https://stackoverflow.com/questions/12030650/when-is-stdweak-ptr-useful?r=SearchResults)



弱引用和强引用非常利于程序的模块化开发，我们可以将程序的扩展模块定义为弱引用，当我们将扩展模块和程序链接在一起时，程序就可以正常使用；如果我们去掉了某些模块，那么程序也可以正常链接，只是缺少了某些功能，这使得程序的功能更加容易裁剪和**(看到有人说，暂时不清楚怎么操作，希望有利于队里程序的开发和调试)**

---



## RAII

[C++经验之谈一：RAII原理介绍](https://zhuanlan.zhihu.com/p/34660259)

[C++经验之谈二：RAII的运用](https://zhuanlan.zhihu.com/p/99348145)

### 什么是RAII

RAII（**R**esource **A**cquisition **I**s **I**nitialization）是由C++之父Bjarne Stroustrup提出的，中文翻译为资源获取即初始化，他说：使用局部对象来管理资源的技术称为资源获取即初始化；这里的资源主要是指操作系统中有限的东西如内存、网络套接字等等，局部对象是指存储在栈的对象，它的生命周期是由操作系统来管理的，无需人工介入。**RAII机制是一种对资源申请、释放这种成对的操作的封装， 通过这种方式实现在局部作用域内申请资源然后销毁资源。**

### RAII原理

资源的使用一般经历三个步骤

- 获取资源 
- 使用资源 
- 销毁资源

但是资源的销毁往往是程序员经常忘记的一个环节，所以**程序界就想如何在程序员中让资源自动销毁呢**？C++之父给出了解决问题的方案：RAII，**它充分的利用了C++语言局部对象自动销毁的特性来控制资源的生命周期**。给一个简单的例子来看下局部对象的自动销毁的特性：

```cpp
#include <iostream>
using namespace std;
class person {
  public:
      person(const std::string name = "", int age = 0) : 
      name_(name), age_(age) {
            std::cout << "Init a person!" << std::endl;
      }
      ~person() {
            std::cout << "Destory a person!" << std::endl;
      }
      const std::string& getname() const {
            return this->name_;
      }    
      int getage() const {
            return this->age_;
      }      
  private:
      const std::string name_;
      int age_;  
};
int main() {
    person p;
    return 0;
}
//编译并运行：
g++ person.cpp -o person
./person 
//运行结果：
Init a person!
Destory a person!
```

从person class可以看出，当我们在main函数中声明一个局部对象的时候，会自动调用构造函数进行对象的初始化，当整个main函数执行完成后，自动调用析构函数来销毁对象，整个过程无需人工介入，由操作系统自动完成；于是，很自然联想到，当我们在使用资源的时候，在构造函数中进行初始化，在析构函数中进行销毁。整个RAII过程可以总结为四个步骤：

- 设计一个类封装资源

- 在构造函数中初始化

- 在析构函数中执行销毁操作

- 使用时声明一个该对象的类

### RAII的应用

#### 示例

本节主要通过一个简单的例子来说明如何将RAII应用到我们的代码中。linux下经常会使用多线程技术，说到多线程，就得提到互斥锁，互斥锁主要用于互斥，互斥是一种**竞争关系**，用来保护临界资源一次只被一个线程访问，按照我们前面的分析，我们封装一下POSIX标准的互斥锁：

```cpp
#include <pthread.h>
#include <cstdlib>
#include <stdio.h>

class Mutex {
 public:
  Mutex();
  ~Mutex();

  void Lock();
  void Unlock(); 

 private:
  pthread_mutex_t mu_;

  // No copying 这里是rust的写法；C++11里面，防止拷贝应该把拷贝构造函数和拷贝赋值运算符设为删除的
  Mutex(const Mutex&);
  void operator=(const Mutex&);
};


#include "mutex.h"

static void PthreadCall(const char* label, int result) {
  if (result != 0) {
    fprintf(stderr, "pthread %s: %s\n", label, strerror(result));
  }
}

Mutex::Mutex() { PthreadCall("init mutex", pthread_mutex_init(&mu_, NULL)); }

Mutex::~Mutex() { PthreadCall("destroy mutex", pthread_mutex_destroy(&mu_)); }

void Mutex::Lock() { PthreadCall("lock", pthread_mutex_lock(&mu_)); }

void Mutex::Unlock() { PthreadCall("unlock", pthread_mutex_unlock(&mu_)); }
```

> RAII对象也可以进行复制，但是拷贝的时候必须要一并复制它所管理的资源。一般设置为不可拷贝是为了防止误拷贝时使用了自动生成的拷贝函数，自动生成的函数一般进行的是浅拷贝。

写到这里其实就可以使用Mutex来锁定临界区，但我们发现Mutex只是用来对锁的初始化和销毁，我们还得在代码中调用Lock和Unlock函数，这又是一个对立操作，所以我们可以继续使用RAII进行封装，代码如下：

```cpp
#include "mutex.h"

class  MutexLock {
 public:
  explicit MutexLock(Mutex *mu)
      : mu_(mu)  {
    this->mu_->Lock();
  }
  ~MutexLock() { this->mu_->Unlock(); }

 private:
  Mutex *const mu_;
  // No copying allowed
  MutexLock(const MutexLock&);
  void operator=(const MutexLock&);
};
```

到这里我们就真正封装了互斥锁，下面我们来通过一个简单的例子来使用它，代码如下：

```cpp
#include "mutexlock.hpp"
#include <unistd.h>
#include <iostream>

#define    NUM_THREADS     10000

int num=0;
Mutex mutex;

void *count(void *args) {
    MutexLock lock(&mutex);
    num++;
}


int main() {
    int t;
    pthread_t thread[NUM_THREADS];

    for( t = 0; t < NUM_THREADS; t++) {   
        int ret = pthread_create(&thread[t], NULL, count, NULL);
        if(ret) {   
            return -1;
        }   
    }

    for( t = 0; t < NUM_THREADS; t++){
         pthread_join(thread[t], NULL);
    }       
    std::cout << num << std::endl;
    return 0;
}

//编译并运行：
g++ test_mutexlock.cpp mutexlock.hpp mutex.cpp mutex.h -o test_mutexlock -lpthread
./test_mutexlock 
//运行结果：
    10000  
//符合预期（可以去掉MutexLock lock(&mutex);试试看看结果如何？）
```

#### 裸指针的痛点

```cpp
int *p = new int(10);
/*do something*/
delete p;
```

上面的代码如果在do something里面出现异常，那delete永远也无法执行，就会造成内存泄漏，为了防止内存泄漏，是否可以用RAII对指针进行封装，那么当异常发生时候，通过RAII可以自动的执行delete？答案是肯定的，特别是在C++11里面引入智能指针的概念，指针使用的技术就是RAII;本文主要介绍std::unique_ptr的使用。

### `std::unique_ptr`的使用

```cpp
std::unique_ptr<int> up1(new int); //ok 直接初始化
std::unique_ptr<int> up2 = new int;  //error 构造函数explicit
std::unique_ptr<int> up3 = up1;  //error 不可以拷贝
```

某一时刻，只能有一个`std::unique_ptr`指向的对象，不允许多个`std::unique_ptr`指向同一个对象，所以`std::unique_ptr`不支持拷贝和复制；既然`std::unique_ptr`不支持拷贝和复制，那么如何传递和返回参数类型`std::unique_ptr`的对象。

```cpp
//传递引用,不会涉及到拷贝
void func(const std::unique_ptr<int>& up) {
       std::cout << *up << std::endl;
}
```

返回`std::unique_ptr`类型的对象：

```cpp
std::unique_ptr<int> func() {
     return std::unique_ptr<int>(new int(10));  //右值引用（调用移动构造函数） 或者RVO 也可以满足
}
```

### 总结

RAII技术在C++广泛的被使用，在编码的过程中要有意识的去使用该技术，譬如能用智能指针的地方，就不要用裸指针，既然写C++11代码，一定要有这个意识，让内存管理交给代码。

---

## C++11特性

### `thread_local`

`thread_local`是一个**存储器指定符**

> 所谓存储器指定符，其作用类似命名空间，指定了变量名的存储期以及链接方式。同类型的关键字还有
>
> - `register`：自动存储期，指示编译器将此变量置于寄存器中。此关键词已于 C++17 被弃用。
> - `static`：静态或者线程存储期，同时指示是内部链接
> - `extern`：静态或线程存储期，同时提示是外部链接；
> - `thread_local`：线程存储期；
> - `mutable`：不影响存储期或链接

`thread_local` 只对声明于命名空间作用域的对象、声明于块作用域的对象以及静态数据成员允许。它指示对象拥有**线程存储期**。它能与 [static](https://so.csdn.net/so/search?q=static&spm=1001.2101.3001.7020) 或 extern 结合，以分别指定内部或外部链接（除了静态数据成员始终拥有外部链接），但附加的 static 不影响存储期。

> **线程存储期**：对象的存储在线程开始时分配，而在线程结束时解分配。每个线程拥有其自身的对象实例。唯有声明为 thread_local 的对象拥有此存储期。 thread_local 能与 static 或 [extern](https://so.csdn.net/so/search?q=extern&spm=1001.2101.3001.7020) 一同出现，以调整链接。

#### 实践

##### 全局变量

```cpp
#include <iostream>
#include <mutex>
#include <thread>
std::mutex cout_mutex;    //方便多线程打印， 加锁指示为了方便多线程打印

thread_local int x = 1;

void thread_func(const std::string&thread_name){
    for(int i = 0; i < 50; i++){
        x++;
        std::lock_guard<std::mutex> lock(cout_mutex);
        std::cout << "thread[" << thread_name << "]: x = " << x << std::endl;
    }
}

int main() {
    std::thread t1(thread_func, "t1");
    std::thread t2(thread_func, "t2");
    t1.join();
    t2.join();
    return 0;
}
```

每个线程都会在线程初始化时拷贝一个自己的x副本，互不影响。

##### 局部变量

```cpp
#include <iostream>
#include <mutex>
#include <thread>
std::mutex cout_mutex;    //方便多线程打印

void thread_func(const std::string& thread_name) {
    for (int i = 0; i < 3; ++i) {
        thread_local  int x = 1;  //只在每个线程创建时初始化一次
        x++;
        std::lock_guard<std::mutex> lock(cout_mutex);
        std::cout << "thread[" << thread_name << "]: x = " << x << std::endl;
    }
}

int main() {
    std::thread t1(thread_func, "t1");
    std::thread t2(thread_func, "t2");
    t1.join();
    t2.join();
    return 0;
}
```

**只在每个线程创建时初始化一次**

```cpp
thread[t1]: x = 2
thread[t1]: x = 3
thread[t1]: x = 4
thread[t2]: x = 2
thread[t2]: x = 3
thread[t2]: x = 4


```

> 如果不加`thread_local`，相当于局部变量
>
> ```cpp
> thread[t2]: x = 2
> thread[t2]: x = 2
> thread[t2]: x = 2
> thread[t1]: x = 2
> thread[t1]: x = 2
> thread[t1]: x = 2
> 
> ```
>
> 如果改成`static int x = 1;`，每次输出的结果都是不相同的，是线程不安全的
>
> ```cpp
> thread[t2]: x = 3
> thread[t2]: x = 4
> thread[t2]: x = 5
> thread[t1]: x = 5
> thread[t1]: x = 6
> thread[t1]: x = 7
> ```

注意，就是`thread_local `虽然**改变了变量的存储周期，但是并没有改变变量的作用域**，比如上述的局部变量，其使用范围不能超过 for 循环外部，否则编译出错。(`static也没有改变作用域，只是改变存储周期`)

```cpp
void thread_func(const std::string& thread_name) {
    for (int i = 0; i < 3; ++i) {
        thread_local int x = 1; // static int x = 1;
        x++;
        std::lock_guard<std::mutex> lock(cout_mutex);
        std::cout << "thread[" << thread_name << "]: x = " << x << std::endl;
    }
    x++;    //编译会出错：error: ‘x’ was not declared in this scope
    return;
}
```



##### 类对象

```cpp
#include <iostream>
#include <mutex>
#include <thread>
std::mutex cout_mutex;    //方便多线程打印

class A{
public:
    A(){
        std::lock_guard<std::mutex> lock(cout_mutex);
        std::cout << "create A" << std::endl;
    }

    ~A() {
        std::lock_guard<std::mutex> lock(cout_mutex);
        std::cout << "destroy A" << std::endl;
    }

    int counter = 0;
    int get_value() {
        return counter++;
    }
};

void thread_func(const std::string& thread_name) {
    for (int i = 0; i < 3; ++i) {
        thread_local A* a = new A();
        std::lock_guard<std::mutex> lock(cout_mutex);
        std::cout << "thread[" << thread_name << "]: a.counter:" << a->get_value() << std::endl;
    }
    return;
}

int main() {
    std::thread t1(thread_func, "t1");
    std::thread t2(thread_func, "t2");
    t1.join();
    t2.join();
    return 0;
}
//输出
create A
thread[t1]: a.counter:0
thread[t1]: a.counter:1
thread[t1]: a.counter:2
create A
thread[t2]: a.counter:0
thread[t2]: a.counter:1
thread[t2]: a.counter:2
```

类对象的使用和创建和**局部变量**类似，都不会创建多个。这种情况在函数间或通过函数返回实例也是一样的。**thread_local 变量只会在每个线程最开始被调用的时候进行初始化，并且只会被初始化一次，但是可以被多次赋值。**因此 C++ 变量初始化是十分重要的。

##### 类成员变量

规定：**thread_local 作为类成员变量时必须是 static 的**。

```cpp
#include <iostream>
#include <mutex>
#include <thread>
std::mutex cout_mutex;    //方便多线程打印


class B {
public:
    B() {
        std::lock_guard<std::mutex> lock(cout_mutex);
        std::cout << "create B" << std::endl;
    }
    ~B() {
        std::lock_guard<std::mutex> lock(cout_mutex);
        std::cout << "destroy B" << std::endl;
    }
    thread_local static int b_key;
    //thread_local int b_key;
    int b_value = 24;
    static int b_static;
};
thread_local int B::b_key = 12;
int B::b_static = 36;
void thread_func(const std::string& thread_name) {
    B b;
    for (int i = 0; i < 3; ++i) {
        b.b_key--;
        b.b_value--;
        B::b_static--;   // not thread safe
        std::lock_guard<std::mutex> lock(cout_mutex);
        std::cout << "thread[" << thread_name << "]: b_key:" << b.b_key << ", b_value:" << b.b_value << ", b_static:" << b.b_static << std::endl;
        std::cout << "thread[" << thread_name << "]: B::key:" << B::b_key << ", b_value:" << b.b_value << ", b_static: " << B::b_static << std::endl;
    }
    return;
}

int main() {
    std::thread t1(thread_func, "t1");
    std::thread t2(thread_func, "t2");
    t1.join();
    t2.join();
    return 0;
}

```

输出：

```cpp
create B
thread[t2]: b_key:11, b_value:23, b_static:35
thread[t2]: B::key:11, b_value:23, b_static: 35
thread[t2]: b_key:10, b_value:22, b_static:34
thread[t2]: B::key:10, b_value:22, b_static: 34
thread[t2]: b_key:9, b_value:21, b_static:33
thread[t2]: B::key:9, b_value:21, b_static: 33
destroy B
create B
thread[t1]: b_key:11, b_value:23, b_static:32
thread[t1]: B::key:11, b_value:23, b_static: 32
thread[t1]: b_key:10, b_value:22, b_static:31
thread[t1]: B::key:10, b_value:22, b_static: 31
thread[t1]: b_key:9, b_value:21, b_static:30
thread[t1]: B::key:9, b_value:21, b_static: 30
destroy B

Process finished with exit code 0
```

b_key 是 thread_local，虽然其也是 static 的，但是每个线程中有一个，每次线程中的所有调用共享这个变量。b_static 是真正的 static，全局只有一个，所有线程共享这个变量。

> thread_local 适用于每个线程需要自己独立的实例且该实例需要在多个方法中被使用，也即**变量在线程间隔离而在函数或类间共享的场景**





### `std::ref`

**C++11 的std::ref函数就是为了解决在线程的创建中等过程的值拷贝问题，下面将会用一个线程的创建来展示ref函数的作用。**

```cpp
#include <iostream>
#include <thread>
using namespace std;

class A {
public:
	int m_iX;
	A(int x) : m_iX(x) {
		cout << "构造函数  " << this << "   Thread_id: " << this_thread::get_id() << endl;
	}
	A(const A& a) {
		m_iX = a.m_iX;
		cout << "拷贝构造函数  " << this <<"  Thread_id: "<< this_thread::get_id() << endl;
	}
	~A() {
		cout << "析构函数  " << this << "  Thread_id: " << this_thread::get_id() << endl;
	}
};

void fun(const A& b) {
	cout << b.m_iX << endl;
	cout << "子线程  " << &b << "  Thread_id: " << this_thread::get_id() << endl;
}

int main()
{
	A a(10);
	thread t(fun, a);
	t.join();
	return 0;
}
```

简单的实现了一个类，并将其构造函数，拷贝构造函数，析构函数的内存地址以及线程id进行了输出。然后对fun函数创建了线程，参数是A对象的一个引用，理论来说函数中的b应该是主函数中a的一个别名，但是实际运行结果中却显示在创建线程的过程中a对象被拷贝了一份，所以这个传递就变成了一个值传递，运行结果如下图所示：
       <img src="/home/suyu/.config/Typora/typora-user-images/image-20230112184836171.png" alt="image-20230112184836171" style="zoom:80%;" />	

**因为fun函数中的对象和主函数中的对象所在的内存地址不同，所以如果我们想在fun函数中对这个对象进行值的修改的时候在main中就不会起作用，这就失去了引用的一个作用**。 如果我们在fun函数中对该b对象的值进行修改，因为我们传进来的参数是一个const，所以我们可以借助mutable这个关键字，从而达到使这个数据成员可变的效果，于是我们在这个数据成员前加上mutable关键字，然后在fun函数中对其进行修改，然后并在fun函数以及主函数中分别输出对象的值，代码及运行结果如下：

```cpp
#include <iostream>
#include <thread>
using namespace std;

class A {
public:
	mutable int m_iX;         // 添加mutable关键字
	A(int x) : m_iX(x) {
		cout << "构造函数  " << this << "   Thread_id: " << this_thread::get_id() << endl;
	}
	A(const A& a) {
		m_iX = a.m_iX;
		cout << "拷贝构造函数  " << this <<"  Thread_id: "<< this_thread::get_id() << endl;
	}
	~A() {
		cout << "析构函数  " << this << "  Thread_id: " << this_thread::get_id() << endl;
	}
};

void fun(const A& b) {
	b.m_iX = 20;              // 修改b.m_iX的值并输出
	cout << b.m_iX << endl;
	cout << "子线程  " << &b << "  Thread_id: " << this_thread::get_id() << endl;
}

int main()
{
	A a(10);
	thread t(fun, a);
	t.join();
	cout << a.m_iX << endl;           // 输出a.m_iX
	return 0;
}
```

<img src="https://img-blog.csdnimg.cn/20200202185332300.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoYXJsZXNfWmFxZHQ=,size_16,color_FFFFFF,t_70" alt="img" style="zoom:67%;" />

​    如果我们想要实现真正引用的作用，那么就需要借助std::ref的作用了，代码如下：

```cpp
thread t(fun, std::ref(a));
```

​    运行结果如下：

<img src="https://img-blog.csdnimg.cn/20200202185543110.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoYXJsZXNfWmFxZHQ=,size_16,color_FFFFFF,t_70" alt="img" style="zoom:67%;" />

**可以看到参数传递的过程中没有调用拷贝构造函数，而且内存地址相同，更改的值也达到了我们想要的效果，但是为了保证线程的安全，这样的方式不可以用detach使主线程与子线程分开。**

### `std::advance`

#### 动机

我们在遍历标准库容器的时候习惯用iterator([迭代器](https://so.csdn.net/so/search?q=迭代器&spm=1001.2101.3001.7020))去访问容器里面的元素，常用的习惯用法是：

```cpp
std::vector<int> vec;
vec.push_back(100);
vec.push_back(101);
vec.push_back(102);
vec.push_back(103);
vec.push_back(104);

std::vector<int>::iterator it;
std::cout << *it << std::endl;
it+=2;
std::cout << *it << std::endl;
```

上述程序中`it+=2`是将迭代器向后移动两个元素。标准库为我们提供了一个标准的模板操作来代替上述表达式，即std::advance(it, 2), advance的英文含义是增加、向前推。顾名思义就是讲迭代器向前推n个位置。

#### 定义

```cpp
template<class InputIt, class Distance>
void advance(InputIt& it, Distance n);
```

- it: 迭代器变量
- n 需要增加的向量长度

#### 用法

```cpp
#include <iostream>
#include <iterator>
#include <vector>

int main() 
{
    std::vector<int> v{ 3, 1, 4 };

    auto vi = v.begin();

    std::advance(vi, 2);

    std::cout << *vi << '\n';
}

//输出
4
```

#### 总结

- std::advance用来对迭代器做偏移操作
- 在使用前要包含`<iterator>`头文件

### `std::men_fn`

[std::mem_fun](https://blog.csdn.net/qqq1111e/article/details/93056390?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167352031016800211557551%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=167352031016800211557551&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-93056390-null-null.142^v70^control,201^v4^add_ask&utm_term=std%3A%3Amen_fn&spm=1018.2226.3001.4187)

### `std::result_of`

[std::result_of](https://blog.csdn.net/qq_31175231/article/details/77165279?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167352238116800180634315%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=167352238116800180634315&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-77165279-null-null.142^v70^control,201^v4^add_ask&utm_term=std%3A%3Aresult_of&spm=1018.2226.3001.4187)

---



## 底层

### CPU时间片

时间片即CPU分配给各个程序的时间，每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间，使各个程序从表面上看是同时进行的。

如果在时间片结束时进程还在运行，则CPU将被剥夺并分配给另一个进程。如果进程在时间片结束前阻塞或结束，则CPU当即进行切换。而不会造成CPU资源浪费。

在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。

但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。

[CPU时间片](http://wjhsh.net/xingzc-p-6077214.html)



### 虚拟内存与缓存

[高性能C++之虚拟内存](https://www.bilibili.com/video/BV1uK4y1s7rF/?spm_id_from=333.788&vd_source=c5bac967ea2f91153247432d9c1e767d)

[高性能C++之CPU Cache](https://www.bilibili.com/video/BV14o4y1o7y4/?spm_id_from=333.788&vd_source=c5bac967ea2f91153247432d9c1e767d)

## 内存序

### Memory Order

内存顺序描述了计算机 CPU 获取内存的顺序，内存的排序既可能发生在编译器编译期间，也可能发生在 CPU 指令执行期间。

为了尽可能地提高计算机资源利用率和性能，编译器会对代码进行重新排序， CPU 会对指令进行重新排序、延缓执行、各种缓存等等，以达到更好的执行效果。**当然，任何排序都不能违背代码本身所表达的意义**，并且在单线程情况下，通常不会有任何问题。

但是在多线程环境下，比如无锁（lock-free）数据结构的设计中，指令的乱序执行会造成无法预测的行为。所以我们通常引入内存栅栏（Memory Barrier）这一概念来解决可能存在的并发问题。

### Memory Barrier

内存栅栏是一个令 CPU 或编译器在内存操作上限制内存操作顺序的指令，通常意味着在 barrier 之前的指令一定在 barrier 之后的指令之前执行。

在 C11/C++11 中，引入了六种不同的 memory order，可以让程序员在并发编程中根据自己需求尽可能降低同步的粒度，以获得更好的程序性能。这六种 order 分别是：

```cpp
relaxed, acquire, release, consume, acq_rel, seq_cst
```

- `memory_order_relaxed`：只保证当前操作的原子性，不考虑线程间的同步，其他线程可能读到新值，也可能读到旧值。
- `memory_order_release`：（可以理解为 **mutex 的 unlock** 操作）
  1. 对**写入**施加 release 语义（store），在代码中这条语句前面的所有读写操作都无法被重排到这个操作之后，即 store-store 不能重排为 store-store, load-store 也无法重排为 store-load。
  2. 当前线程内的**所有**写操作，对于其他对这个原子变量进行 acquire 的线程可见
  3. 当前线程内的**与这块内存有关**的**所有**写操作，对于其他对这个原子变量进行 consume 的线程可见

- `memory_order_acquire`：（可以理解为 mutex 的 lock 操作）

  1. 对**读取**施加 acquire 语义（load），在代码中这条语句后面所有读写操作都无法重排到这个操作之前，即 load-store 不能重排为 store-load, load-load 也无法重排为 load-load
  2. 在这个原子变量上施加 release 语义的操作发生之后，acquire 可以保证读到所有在 release 前发生的写入，举个例子：

  > ```cpp
  > c = 0;
  > 
  > thread 1:
  > {
  >   a = 1;
  >   b.store(2, memory_order_relaxed);
  >   c.store(3, memory_order_release);
  > }
  > 
  > thread 2:
  > {
  >   while (c.load(memory_order_acquire) != 3);
  >   // 以下 assert 永远不会失败
  >   assert(a == 1 && b == 2);
  >   assert(b.load(memory_order_relaxed) == 2);
  > }
  > ```

- `memory_order_consume`：

  1. 对当前**要读取的内存**施加 release 语义（store），在代码中这条语句后面所有**与这块内存有关的**读写操作都无法被重排到这个操作之前
  2. 在这个原子变量上施加 release 语义的操作发生之后，consume 可以保证读到所有在 release 前发生的**并且与这块内存有关的**写入

  > ```cpp
  > a = 0;
  > c = 0;
  > 
  > thread 1:
  > {
  >   a = 1;
  >   c.store(3, memory_order_release);
  > }
  > 
  > thread 2:
  > {
  >   while (c.load(memory_order_consume) != 3)
  >     ;
  >   assert(a == 1); // assert 可能失败也可能不失败
  > }
  > ```

- `memory_order_acq_rel`：
  1. 对读取和写入施加 acquire-release 语义，无法被重排
  2. 可以看见其他线程施加 release 语义的所有写入，同时自己的 release 结束后所有写入对其他施加 acquire 语义的线程可见

- `memory_order_seq_cst`：

  1. 如果是读取就是 acquire 语义，如果是写入就是 release 语义，如果是读取+写入就是 acquire-release 语义

  2. 同时会对所有使用此 memory order 的原子操作进行同步，所有线程看到的内存操作的顺序都是一样的，就像单个线程在执行所有线程的指令一样

  

> memory order是针对单线程重排序规则的概念，概念本身可以不讲多线程。多线程只是利用了memory order的规则加内存一致性来做线程同步而已。
>
> 第一点，relaxed，线程内不保证所有原子操作是顺序进行的，而是如其字面意思**在不影响逻辑的条件下最大限度的重排序（relax顺序）**，而非relax多线程间任意顺序。
>
> 第二点，release acquice本身是没有什么先后关系的，内存一致性保证了多线程读到的总是最新值，而不是因为release, acquice了才会读到。通常用法是acquice死循环反复读，多次读之后来确认release已经写入了这样做来达到线程同步。
>
> 第三点，release consume同样会影响release前的所有写操作，只要是release,这个之前的操作就不能重排序到release之后。**consume的限制比acquire少的地方在于允许和consum变量无关的操作重排序到consume前**。
>
> 第四点， sequential，就是**各自线程顺序执行不进行重排序而已**，和多线程同步不同步的是两个概念。
>
> 拓展阅读：
>
> [Linux-Kernal-Memory-Barrier](https://links.jianshu.com/go?to=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%3A%2F%2Fgithub.com%2Ftorvalds%2Flinux%2Fblob%2Fmaster%2FDocumentation%2Fmemory-barriers.txt)
>
> [std::memory_order - cppreference.com](https://links.jianshu.com/go?to=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%3A%2F%2Fen.cppreference.com%2Fw%2Fcpp%2Fatomic%2Fmemory_order)
