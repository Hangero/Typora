# 2022哨兵代码阅读

## 目录结构

```shell
.
├── build
│   
├── cmake-build-debug
├── data
├── module
├── param
└── src
    ├── ai_module
    │   ├── 2021_number
    │   ├── 2022_armorDetector#基于OpenVINO的装甲板四点目标检测，在模块thread_module中被实例化，
    │   └── 2022_number#基于OpenVINO的数字识别，该模块在模块 attack_module/algorithm 的 Detect 类的构造函数中被实例
    ├── attack_module#任务类，每个中核心的函数是带有 callBack 或者 loop 的函数，为其任务的线程函数
    │   └── algorithm#核心算法，关于装甲板的检测、轨迹匹配、空间位置求解
    ├── communicate_module#通信线程类，包括和电控通信和发送测试的 loop函数，通过调用底层驱动模块`driver_module`下的`protocol_driver`
                          #来实现串口通信
    ├── driver_module#相机驱动和串口通信底层驱动
    │   ├── base
    │   ├── camera
    │   │   ├── demos
    │   │   │   └── huaray
    │   │   ├── huaray
    │   │   └── tst
    │   ├── MDcamera
    │   │   ├── Data
    │   │   ├── log
    │   │   └── MDVSCam
    │   └── protocol_driver#通信串口
    ├── param_module#加载所有外部和内部的参数并把该类作为全局变量使用
    ├── thread_module#用于控制所有的线程并统一使用一个线程控制
    └── utility_module#各种工具和属性类


```

## 整体理解

### 包含结构

- ThreadController
  - MainTask
    - **armorProperty**
    - algorithm
    - communicate_module
  - GlobalTask
    - ai_module
    - algorithm

对于其他

- param.module：类间通信的中枢
- utility_module：存放通用工具
- driver_module：相机驱动和串口通信底层驱动

> utility_module还存放了LightBar(结构体)，armorPlate(类)，Trajectory(类)，GlobalTrajectory(类)，而且只有成员变量，没有成员函数，很值得推敲



### CMake管理

#### 编译成动态库

```cmake
#作用是发现一个目录下所有的源代码文件并将列表存储在一个变量中,这个指令临时被用来自动构建源文件列表。因为目前 cmake 还不能自动发现新添加的源文件。
aux_source_directory(. DIR_COMMUNICATE)
#生成动态库
add_library(communicate SHARED ${DIR_COMMUNICATE})
#该命令可以指定目标（exe或者so文件）需要包含的头文件路径。命名的<目标>必须是由add_executable()或add_library()之类的命令创建的，并且不能是ALIAS目标
target_include_directories(communicate PUBLIC . ../utility_module ../param_module)
#这个指令可以用来为 target 添加需要链接的共享库,本例中是一个可执行文件,但是同样可以用于为自己编写的共享库添加共享库链接。
target_link_libraries(communicate
        param
        utility)
```

#### 管理下级CMakeLists

```cmake
#根目录CMake
add_subdirectory(src)

#src目录CMake
add_subdirectory(ai_module)
add_subdirectory(driver_module)
add_subdirectory(utility_module)
add_subdirectory(param_module)
add_subdirectory(communicate_module)
add_subdirectory(attack_module)
add_subdirectory(thread_module)

#attack_module目录CMake
add_subdirectory(algorithm)

```

#### 生成可执行文件

```cmake
#通过根目录CMake控制./src/main.cpp生成可执行文件
add_executable(RM_Sentry_Run  ./src/main.cpp)# 可执行文件

#通过设置变量生成可执行文件
aux_source_directory(. SRC_LIST)
add_executable(demo ${SRC_LIST} )
```

#### 辅助操作

```cmake
#输出信息
message(STATUS "main函数目录:${SRC_LIST}")
```



## Param

```cpp
#include "../driver_module/camera/huaray/HuarayCam.h"
#include "../driver_module/MDcamera/MDVSCam/MDVSCam.h"
#include "../driver_module/protocol_driver/SerialApp.h"
#include "../utility_module/Window.h"//通道类，用于管理每一个窗口上的显示位置和信息
#include "../utility_module/SharedObject.h"//通信共享体，用于线程之间；结果共享体，用于全局视野和主线程
#include "fstream"
```

==只利用了最基本的C++变量类型和相机驱动里的内容==

### `Param.h`

在全局区开辟区域（注册了变量名，但没有分配内存空间），但是没有初始化，一定要初始化之后才可以用

### `Param.cpp`

- 初始化变量
- 实现`Param`类中的成员变量`void param::loadParam()`，通过`cv::FileStorage`和`cv::FileNode`读取`param.yaml`，并设置静态变量

```cpp
#define PARAM_FILE_PATH "../param/param.yaml"
cv::FileStorage fs(cv::String(PARAM_FILE_PATH), cv::FileStorage::READ);

cv::FileNode node_control = fs["CONTROL"];
cv::FileNode control_inter = node_control["INTER"];

control_inter["PROCESS"] >> param::PROCESS;
```



> **#ifndef 条件编译**
> 　　它是if not define 的简写，是宏定义的一种，实际上确切的说，这应该是预处理功能三种（宏定义、文件包含、条件编译）中的一种----条件编译。
>
> 　　在c语言中，对同一个变量或者函数进行多次声明是不会报错的。所以如果h文件里只是进行了声明工作，即使不使用# ifndef宏定义，多个c文件包含同一个h文件也不会报错。
>
> 　　但是在c++语言中，#ifdef的作用域只是在单个文件中。所以如果h文件里定义了全局变量，即使采用#ifdef宏定义，多个c文件包含同一个h文件还是会出现全局变量重定义的错误。
>
> 使用#ifndef可以避免下面这种错误：如果在h文件中定义了全局变量，一个c文件包含同一个h文件多次，如果不加#ifndef宏定义，会出现变量重复定义的错误；如果加了#ifndef，则不会出现这种错误。
>
> ```cpp
> #ifdef _HAVE_SERIAL_
>     param::SERIAL = std::make_unique<SerialApp>(param::SERIAL_DEVICE,param::BAUD_RATE);
> #endif
> //注意：param.yaml中
> SERIAL_DEVICE: "auto"
> ```



```cpp
bool param::PROCESS;
boost::atomic<bool> param::APROCESS;

if(param::PROCESS){
        param::APROCESS.store(true,boost::memory_order_release);
    }else{
        param::APROCESS.store(false,boost::memory_order_release);
    }
```

[boost::atomic](https://blog.csdn.net/zhizhengguan/article/details/118540569?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167127841216800213064970%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=167127841216800213064970&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-118540569-null-null.142^v68^control,201^v4^add_ask,213^v2^t3_esquery_v1&utm_term=boost%3A%3Aatomic&spm=1018.2226.3001.4187)

[boost::memory_order_release](https://blog.csdn.net/mw_nice/article/details/84861651?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167127856216782427417081%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=167127856216782427417081&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-84861651-null-null.142^v68^control,201^v4^add_ask,213^v2^t3_esquery_v1&utm_term=boost%3A%3Amemory_order_release&spm=1018.2226.3001.4187)



### `param.yaml`



## ThreadContorller

```cpp
#include <boost/thread.hpp>
#include "opencv2/opencv.hpp"
#include "../param_module/Param.h"
#include "../communicate_module/Communicator.h"
#include "../attack_module/MainTask.h"
#include "../attack_module/GlobalTask.h"
#include "../utility_module/ThreadWatcher.h"//线程帧率测试类，用于每一个线程的帧率测试
```

- `private`:

  - ```cpp
    std::shared_ptr<Communicator> m_communicatorPtr;
    std::shared_ptr<MainTask> m_mainTaskPtr;
    std::shared_ptr<LeftTask> m_leftTaskPtr;
    std::shared_ptr<RightTask> m_rightTaskPtr;
    std::shared_ptr<BackTask> m_backTaskPtr;
    ```

  - ```cpp
    boost::thread m_communicateThread;
    boost::thread m_sendTestThread;
    boost::thread m_saveVideoThread;
    boost::thread m_consoleThread;
    boost::thread m_backTaskThread;
    ```

  - `void runConsole()`

- `public`:

  - `void run()` 

###        `void runConsole()`

```cpp
/**
 * 交互线程
 * @param
 * @return
 */
void ThreadController::runConsole() {
    while (param::APROCESS.load(boost::memory_order_acquire)) {
        boost::this_thread::interruption_point(); // why use thiS TODO
        char ch = getchar();           ///获取输入
        if (ch == 'q' || ch == 'Q') {  ///终端输入Q,q结束代码
            std::cout << "wait all thread disconnect......" << std::endl;
            param::APROCESS.store(false, boost::memory_order_release);  ///改变全局标志变量，结束其它所有线程
            boost::this_thread::sleep(boost::posix_time::seconds(2));
            if (!param::SEND_TEST) {
                param::cam.terminate();
                std::cout << "main camera end" << std::endl;
                if (param::DISPLAY) {
                    std::cout << "close Image......" << std::endl;
                    param::DISPLAY = false;
                    cv::destroyAllWindows();
                }
                if (param::GLOBAL_DETECT) {
                    param::MDcam1.close();
                    param::MDcam2.close();
                }
            }
        } else if (ch == 'w' || ch == 'W') {
            param::USE_CLASSIFIER = !param::USE_CLASSIFIER;
            if (param::USE_CLASSIFIER) {
                std::cout << "数字识别开启" << std::endl;
            } else {
                std::cout << "数字识别关闭" << std::endl;
            }
        } else if (ch == 'e' || ch == 'E') {
            param::DISPLAY = !param::DISPLAY;
            if (param::DISPLAY) {
                std::cout << "图像显示开启" << std::endl;
            } else {
                cv::destroyAllWindows();
                std::cout << "图像显示关闭" << std::endl;
            }
        } else if (ch == 'r' || ch == 'R') {
            //保存数字识别图像
            param::SAVE_PIC = !param::SAVE_PIC;
        } else if (ch == 't' || ch == 'T') {
#ifdef _HAVE_SERIAL_
            param::ANTI_COLOR = !param::ANTI_COLOR;
#else
            param::s_comData.ENEMY = !param::s_comData.ENEMY;
#endif
            std::cout << "攻击颜色反转" << std::endl;
        } else if (ch == 'a' || ch == 'A') {
            //用于测试通信线程的帧率
            param::VERBOSE_COMMUNICATE = !param::VERBOSE_COMMUNICATE;
        } else if (ch == 's' || ch == 'S') {
            //用于测试抓图回调函数的帧率
            param::VERBOSE_MAINTASK = !param::VERBOSE_MAINTASK;
        } else if (ch == 'd' || ch == 'D') {
            //用于测试 MD 1 的帧率
            param::VERBOSE_MD_1 = !param::VERBOSE_MD_1;
        } else if (ch == 'f' || ch == 'F') {
            //用于测试 MD 2 的帧率
            param::VERBOSE_MD_2 = !param::VERBOSE_MD_2;
        } else if (ch == 'g' || ch == 'G') {
            //用于测试 MD 3 的帧率
            param::VERBOSE_USB_3 = !param::VERBOSE_USB_3;
        } else if (ch == 'z' || ch == 'Z') {
            //用于显示发送的数据
            param::VERBOSE_SEND = !param::VERBOSE_SEND;
        } else if (ch == 'x' || ch == 'X') {
            //用于小陀螺测试显示
            param::VERBOSE_XTL = !param::VERBOSE_XTL;
        } else if (ch == 'c' || ch == 'C') {
            // 保存KMF数据
            param::SAVE_KMF = !param::SAVE_KMF;
        } else if (ch == 'v' || ch == 'V') {
            //数字识别检测输出 TODO
        } else if (ch == 'b' || ch == 'B') {
        } else if (ch == 'v' || ch == 'V') {
        } else if (ch == 'h' || ch == 'H') {
            ///测试是否处于 Debug 状态，调出按键列表
            std::cout << "============ Key Func =============" << std::endl
                      << "q/Q: 退出程序" << std::endl
                      << "w/W: 数字识别开关" << std::endl
                      << "e/E: 图像显示开关" << std::endl
                      << "r/R: 开始保存数字数据(需先修改参数表)" << std::endl
                      << "t/T: 切换攻击颜色" << std::endl
                      << "a/A: 通信线程接收测试" << std::endl
                      << "s/S: 主相机回调帧率测试" << std::endl
                      << "d/D: 全局 左 帧率测试" << std::endl
                      << "f/F: 全局 右 帧率测试" << std::endl
                      << "g/G: 全局 后 帧率测试" << std::endl
                      << "z/Z: 显示发送的数据" << std::endl
                      << "x/X: 显示小陀螺数据" << std::endl
                      << "c/C: 保存KMF数据" << std::endl
                      << "v/V: " << std::endl
                      << "b/B: " << std::endl
                      << "y/Y: 修改主图像显示通道(WaitKey)" << std::endl
                      << "u/U: 主图像显示挂起(WaitKey)" << std::endl
                      << "i/I: 全局图像显示挂起(WaitKey)" << std::endl
                      << "o/O: 数字图像显示挂起(WaitKey)" << std::endl
                      << "h/H: Help" << std::endl
                      << "============ Key Func =============" << std::endl;
        }
        boost::this_thread::sleep(boost::posix_time::milliseconds(
                2000));  ///休眠2s，因为这不是什么重要的线程，2s读一次数就够了，把资源让给其它线程
    }
    std::cout << "Mutual Thread Close!" << std::endl;
}

```

#### `boost::this_thread::interruption_point()`

[boost库中thread多线程详解5——谈谈线程中断](https://blog.csdn.net/liujiayu2/article/details/50586999?ops_request_misc=&request_id=&biz_id=102&utm_term=boost::this_thread::interrupti&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-50586999.142^v68^control,201^v4^add_ask,213^v2^t3_esquery_v1&spm=1018.2226.3001.4187)

#### 交互线程总开关

```cpp
        if (ch == 'q' || ch == 'Q') {  ///终端输入Q,q结束代码
            std::cout << "wait all thread disconnect......" << std::endl;
            param::APROCESS.store(false, boost::memory_order_release);  ///改变全局标志变量，结束其它所有线程
            boost::this_thread::sleep(boost::posix_time::seconds(2));
            if (!param::SEND_TEST) {
                param::cam.terminate();
                std::cout << "main camera end" << std::endl;
                if (param::DISPLAY) {
                    std::cout << "close Image......" << std::endl;
                    param::DISPLAY = false;
                    cv::destroyAllWindows();
                }
                if (param::GLOBAL_DETECT) {
                    param::MDcam1.close();
                    param::MDcam2.close();
                }
```

- `param::APROCESS.store(false, boost::memory_order_release)`
- `param::cam.terminate();`
- ` param::DISPLAY = false;`

#### 其他开关

```cpp
else if (ch == 'w' || ch == 'W') {
            param::USE_CLASSIFIER = !param::USE_CLASSIFIER;
            if (param::USE_CLASSIFIER) {
                std::cout << "数字识别开启" << std::endl;
            } else {
                std::cout << "数字识别关闭" << std::endl;
            }
```

均是对`param`类的静态变量取反，结束相应功能。

### `void run()`

```cpp
/**
 * 总线程启动函数
 * @param
 * @return
 */
void ThreadController::run() {
    /// 通信任务对象
    ThreadWatcher sendTestThreadWatcher(10); /// 自定义帧数平滑测试
    ThreadWatcher communicateThreadWatcher(200);
    m_communicatorPtr = std::make_shared<Communicator>(std::make_shared<ThreadWatcher>(sendTestThreadWatcher),
                                                       std::make_shared<ThreadWatcher>(communicateThreadWatcher));
////////////////////////////////////通信测试线程////////////////////////////////////////////
    if (param::SEND_TEST) {
        /// 通信测试，单独执行，不会添加其他线程
        m_sendTestThread =
                boost::thread([&] { m_communicatorPtr->sendTestLoop(); });
        /// boost::thread([this, &sendTestThreadWatcher] { m_communicatorPtr->sendTestLoop(sendTestThreadWatcher); });
        std::cout << "sendTestThread ID: " << m_sendTestThread.get_id() << std::endl;
        m_sendTestThread.detach(); /// mean that after run() terminate, it terminate too.
    } else {
 ////////////////////////////////////正式程序////////////////////////////////////////////  
        
        /////////////////////////////接受电控数据线程///////////////////////////////
        m_communicateThread =
                boost::thread([&] { m_communicatorPtr->receiveLoop(); });
        /// boost::thread([this, &communicateThreadWatcher] { m_communicatorPtr->receiveLoop(communicateThreadWatcher); });
        std::cout << "communicateThread ID: " << m_communicateThread.get_id() << std::endl;
        m_communicateThread.detach();
        
        /////////////////////////////主相机任务//////////////////////////////// 
       
        ThreadWatcher mainTaskWatcher(200);
        m_mainTaskPtr = std::make_shared<MainTask>(std::make_shared<ThreadWatcher>(mainTaskWatcher));
        hitcrt::camera::Mode tmode;
        if (param::TRIGER_MODE == 0) {
            tmode = hitcrt::camera::Mode::STREAM;
        } else {
            tmode = hitcrt::camera::Mode::LINE;
        }
        param::camParams.set(
                boost::bind(&MainTask::mainTaskCallBack, m_mainTaskPtr, _1, _2), 0, tmode,
                param::FRAME_WIDTH, param::FRAME_HEIGHT, param::BLACKLEVEL,
                param::BRIGHTNESS, param::DIGITALSHIFT, param::SHARPNESS,
                param::EXPOSURE_L, param::GAMA, param::GAINRAW, param::BALANCE,
                std::function<void()>([]() { std::cout << "Cam Off Line" << std::endl; }),
                std::function<void()>([]() { std::cout << "Cam On Line" << std::endl; }));
        /// *[](){ std::cout << "Cam On Line" << std::endl; } ?????
        param::cam.initiate(param::camParams);
        std::cout << "mainTaskCallBack start" << std::endl; /// 回调函数默认和这里的区域应该是detach的关系
        /// 主相机保存视频
        if (param::SAVE_VIDEO) {
            m_saveVideoThread = boost::thread([&] { m_mainTaskPtr->saveVideoLoop(); });
            /// boost::thread([this] { m_mainTaskPtr->saveVideoLoop(); });
            m_saveVideoThread.detach();
            std::cout << "saveVideoThread ID: " << m_saveVideoThread.get_id() << std::endl;
        }
        
        /////////////////////////////全局视野//////////////////////////////// 
       
        if (param::GLOBAL_DETECT) {
            /// 初始化检测类，给多个任务调用
            auto detectorGPUPtr = std::make_shared<Detector>();
            auto detectorCPUPtr = std::make_shared<Detector>();
            detectorGPUPtr->init(param::DETECTOR_XML_PATH_GPU, Detector::CFdevice::GPU, param::MD_FRAME_WIDTH_1,
                                 param::MD_FRAME_HEIGHT_1,
                                 param::IF_DRAW, param::REQ_NUM_GPU, param::SCORE_THRES_GPU, param::NMS_THRES_GPU);
//            detectorCPUPtr->init(param::DETECTOR_XML_PATH_CPU, Detector::CFdevice::CPU, param::USB_FRAME_WIDTH_3,
//                                 param::USB_FRAME_HEIGHT_3,
//                                 param::IF_DRAW, param::REQ_NUM_CPU, param::SCORE_THRES_CPU, param::NMS_THRES_CPU);

            /// 三个任务
            ThreadWatcher leftTaskWatcher(30);
            ThreadWatcher rightTaskWatcher(30);
            ThreadWatcher backTaskWatcher(30);
            m_leftTaskPtr = std::make_shared<LeftTask>(detectorGPUPtr,
                                                       std::make_shared<ThreadWatcher>(leftTaskWatcher));
            m_rightTaskPtr = std::make_shared<RightTask>(detectorGPUPtr,
                                                         std::make_shared<ThreadWatcher>(rightTaskWatcher));
//            m_backTaskPtr = std::make_shared<BackTask>(detectorCPUPtr);
            param::MDcamParams1 = hitcrt::camera::MDVSCam_Param(
                    boost::bind(&LeftTask::leftTaskCallBack, m_leftTaskPtr, _1, _2), param::MD_ID_1,
                    hitcrt::camera::STREAM, param::MD_FRAME_WIDTH_1, param::MD_FRAME_HEIGHT_1, param::MD_BLACKLEVEL_1,
                    param::MD_BRIGHTNESS_1, param::MD_DIGITALSHIFT_1, param::MD_SHARPNESS_1, param::MD_EXPOSURE_L_1,
                    param::MD_GAMA_1, param::MD_GAINRAW_1, param::MD_SN_1, param::MD_BALANCE_1);
            param::MDcamParams2 = hitcrt::camera::MDVSCam_Param(
                    boost::bind(&RightTask::rightTaskCallBack, m_rightTaskPtr, _1, _2), param::MD_ID_2,
                    hitcrt::camera::STREAM, param::MD_FRAME_WIDTH_2, param::MD_FRAME_HEIGHT_2, param::MD_BLACKLEVEL_2,
                    param::MD_BRIGHTNESS_2, param::MD_DIGITALSHIFT_2, param::MD_SHARPNESS_2, param::MD_EXPOSURE_L_2,
                    param::MD_GAMA_2, param::MD_GAINRAW_2, param::MD_SN_2, param::MD_BALANCE_2);
            param::MDcam1.initiate(param::MDcamParams1);
            param::MDcam2.initiate(param::MDcamParams2);
//            m_backTaskThread = boost::thread([&] { m_backTaskPtr->backTaskLoop(backTaskWatcher); }); TODO
//            m_backTaskThread.detach();
//            std::cout << "backTaskThread ID: " << m_backTaskThread.get_id() << std::endl;
        }
    }
    /////////////////////////////交互线程//////////////////////////////// 
    m_consoleThread =
            boost::thread([&] { runConsole(); });//交互线程
    /// boost::thread([this] { runConsole(); });
    std::cout << "consoleThread ID: " << m_consoleThread.get_id() << std::endl;
    m_consoleThread.join(); /// 阻止任务对象析构
}

```

#### 线程监控

```cpp
 /// 通信任务对象
    ThreadWatcher sendTestThreadWatcher(10); /// 自定义帧数平滑测试
    ThreadWatcher communicateThreadWatcher(200);
    m_communicatorPtr = std::make_shared<Communicator>(std::make_shared<ThreadWatcher>(sendTestThreadWatcher),std::make_shared<ThreadWatcher>(communicateThreadWatcher));
```



#### 通信测试线程

不加入其他线程，仅仅与电控进行调试

```cpp
if (param::SEND_TEST) {
        /// 通信测试，单独执行，不会添加其他线程
        m_sendTestThread =
                boost::thread([&] { m_communicatorPtr->sendTestLoop(); });
        /// boost::thread([this, &sendTestThr程序eadWatcher] { m_communicatorPtr->sendTestLoop(sendTestThreadWatcher); });
        std::cout << "sendTestThread ID: " << m_sendTestThread.get_id() << std::endl;
        m_sendTestThread.detach(); /// mean that after run() terminate, it terminate too.
    }
```

C++多线程和detach相对的函数有join，`join`的意思是父线程等待子线程结束，而`detach`的含义是主线程和子线程相互分离，互不干扰，当`run()`结束时，`m_sendTestThread`线程也结束，但是注意，因为父线程和子线程完全独立，可能存在资源未释放。

#### 正式程序

##### 接受电控数据主线程

```cpp
m_communicateThread =
                boost::thread([&] { m_communicatorPtr->receiveLoop(); });
        /// boost::thread([this, &communicateThreadWatcher] { m_communicatorPtr->receiveLoop(communicateThreadWatcher); });
        std::cout << "communicateThread ID: " << m_communicateThread.get_id() << std::endl;
        m_communicateThread.detach();
```

##### 主相机任务

```cpp
/// 主相机任务
        ThreadWatcher mainTaskWatcher(200);
        m_mainTaskPtr = std::make_shared<MainTask>(std::make_shared<ThreadWatcher>(mainTaskWatcher));
        hitcrt::camera::Mode tmode;
        if (param::TRIGER_MODE == 0) {
            tmode = hitcrt::camera::Mode::STREAM;
        } else {
            tmode = hitcrt::camera::Mode::LINE;
        }
        param::camParams.set(
                boost::bind(&MainTask::mainTaskCallBack, m_mainTaskPtr, _1, _2), 0, tmode,
                param::FRAME_WIDTH, param::FRAME_HEIGHT, param::BLACKLEVEL,
                param::BRIGHTNESS, param::DIGITALSHIFT, param::SHARPNESS,
                param::EXPOSURE_L, param::GAMA, param::GAINRAW, param::BALANCE,
                std::function<void()>([]() { std::cout << "Cam Off Line" << std::endl; }),
                std::function<void()>([]() { std::cout << "Cam On Line" << std::endl; }));
        /// *[](){ std::cout << "Cam On Line" << std::endl; } ?????
        param::cam.initiate(param::camParams);
        std::cout << "mainTaskCallBack start" << std::endl; /// 回调函数默认和这里的区域应该是detach的关系
        /// 主相机保存视频
        if (param::SAVE_VIDEO) {
            m_saveVideoThread = boost::thread([&] { m_mainTaskPtr->saveVideoLoop(); });
            /// boost::thread([this] { m_mainTaskPtr->saveVideoLoop(); });
            m_saveVideoThread.detach();
            std::cout << "saveVideoThread ID: " << m_saveVideoThread.get_id() << std::endl;
        }
```



##### 全局视野

```cpp
/// 全局视野
        if (param::GLOBAL_DETECT) {
            /// 初始化检测类，给多个任务调用
            auto detectorGPUPtr = std::make_shared<Detector>();
            auto detectorCPUPtr = std::make_shared<Detector>();
            detectorGPUPtr->init(param::DETECTOR_XML_PATH_GPU, Detector::CFdevice::GPU, param::MD_FRAME_WIDTH_1,
                                 param::MD_FRAME_HEIGHT_1,
                                 param::IF_DRAW, param::REQ_NUM_GPU, param::SCORE_THRES_GPU, param::NMS_THRES_GPU);
//            detectorCPUPtr->init(param::DETECTOR_XML_PATH_CPU, Detector::CFdevice::CPU, param::USB_FRAME_WIDTH_3,
//                                 param::USB_FRAME_HEIGHT_3,
//                                 param::IF_DRAW, param::REQ_NUM_CPU, param::SCORE_THRES_CPU, param::NMS_THRES_CPU);

            /// 三个任务
            ThreadWatcher leftTaskWatcher(30);
            ThreadWatcher rightTaskWatcher(30);
            ThreadWatcher backTaskWatcher(30);
            m_leftTaskPtr = std::make_shared<LeftTask>(detectorGPUPtr,
                                                       std::make_shared<ThreadWatcher>(leftTaskWatcher));
            m_rightTaskPtr = std::make_shared<RightTask>(detectorGPUPtr,
                                                         std::make_shared<ThreadWatcher>(rightTaskWatcher));
//            m_backTaskPtr = std::make_shared<BackTask>(detectorCPUPtr);
            /////////设置相机参数
            ///迈威相机1
            param::MDcamParams1 = hitcrt::camera::MDVSCam_Param(
                    boost::bind(&LeftTask::leftTaskCallBack, m_leftTaskPtr, _1, _2), param::MD_ID_1,
                    hitcrt::camera::STREAM, param::MD_FRAME_WIDTH_1, param::MD_FRAME_HEIGHT_1, param::MD_BLACKLEVEL_1,
                    param::MD_BRIGHTNESS_1, param::MD_DIGITALSHIFT_1, param::MD_SHARPNESS_1, param::MD_EXPOSURE_L_1,
                    param::MD_GAMA_1, param::MD_GAINRAW_1, param::MD_SN_1, param::MD_BALANCE_1);
             ///迈威相机2
            param::MDcamParams2 = hitcrt::camera::MDVSCam_Param(
                    boost::bind(&RightTask::rightTaskCallBack, m_rightTaskPtr, _1, _2), param::MD_ID_2,
                    hitcrt::camera::STREAM, param::MD_FRAME_WIDTH_2, param::MD_FRAME_HEIGHT_2, param::MD_BLACKLEVEL_2,
                    param::MD_BRIGHTNESS_2, param::MD_DIGITALSHIFT_2, param::MD_SHARPNESS_2, param::MD_EXPOSURE_L_2,
                    param::MD_GAMA_2, param::MD_GAINRAW_2, param::MD_SN_2, param::MD_BALANCE_2);
            ///相机初始化
            param::MDcam1.initiate(param::MDcamParams1);
            param::MDcam2.initiate(param::MDcamParams2);
```



##### 交互线程

```cpp
    m_consoleThread =
            boost::thread([&] { runConsole(); });//交互线程
    /// boost::thread([this] { runConsole(); });
    std::cout << "consoleThread ID: " << m_consoleThread.get_id() << std::endl;
    m_consoleThread.join(); /// 阻止任务对象析构
```



## `MainTask`

```cpp
#include "../param_module/Param.h"
#include "../communicate_module/Communicator.h"
#include "../utility_module/ThreadWatcher.h"
#include "../utility_module/armorProperty.h"
#include "../utility_module/Utility.h"
#include "../utility_module/ROITool.h"
#include "../utility_module/Filter.h"
#include "algorithm/Detect.h"//装甲板检测
#include "algorithm/Associate.h"//规矩匹配
```



- `private`

- `public`:

  ```cpp
   explicit MainTask(std::shared_ptr<ThreadWatcher> mMainTaskCallBackWatcherPtr);
  
      ~MainTask();
  
      void saveVideoLoop();
  
      void mainTaskCallBack(
              const hitcrt::camera::TimePoint &timeStamp,
              const cv::Mat &frameImage);
  ```



### `MainTask()`

```cpp
/**
 *@brief 构造函数
 *@return
 * */

MainTask::MainTask(std::shared_ptr<ThreadWatcher> mMainTaskCallBackWatcherPtr) : m_mainTaskCallBackWatcherPtr(
        std::move(mMainTaskCallBackWatcherPtr)) {
    //装甲板识别
    m_detectMethPtr = std::make_shared<Detect>();
    //ROI处理
    m_roiToolPtr = std::make_shared<ROITool>(param::FRAME_WIDTH, param::FRAME_HEIGHT, param::ROI_SCALE);
    //规矩匹配
    m_assioMethPtr = std::make_shared<Associate>();
    m_assioMethXtlPtr = std::make_shared<Associate>();
    //卡尔曼滤波
    m_singerKMFPitchPtr = std::make_shared<Singer>();
    m_singerKMFYawPtr = std::make_shared<Singer>();
};
```



### `void saveVideoLoop();`

```cpp
/**
 *@brief 大华视频保存
 *@return
 * */
void MainTask::saveVideoLoop() {
    std::string videoName;
    std::string videoRoiName;
    //Utility.h
    getFileName("video", videoName);
    getFileName("video_roi", videoRoiName);
    //为视频添加后缀“.avi”
    std::string filename = SAVE_VIDEO_PATH + videoName + ".avi";
    std::string filename_roi = SAVE_VIDEO_PATH + videoRoiName + ".avi";

    cv::Mat frametemp;
    cv::Mat frametemp_roi;
    //初始化writer
    cv::VideoWriter writer(filename,
                           cv::VideoWriter::fourcc('M', 'J', 'P', 'G'), 20,
                           cv::Size(param::FRAME_WIDTH, param::FRAME_HEIGHT));
    cv::VideoWriter writer_roi(
            filename_roi, cv::VideoWriter::fourcc('M', 'J', 'P', 'G'), 20,
            cv::Size(param::FRAME_WIDTH, param::FRAME_HEIGHT));

    while (param::APROCESS.load(boost::memory_order_acquire)) {
        boost::this_thread::interruption_point();
        {
            boost::shared_lock<boost::shared_mutex> readLock(
                    param::saveVideoMutex);  ///上锁
            if (!m_saveFrame.empty()) {
                frametemp = m_saveFrame.clone();
            } else {
                continue;
            }
            if (!m_saveFrame_roi.empty()) {
                frametemp_roi = m_saveFrame_roi.clone();
            } else {
                continue;
            }
            readLock.unlock();
        }
        //视频按帧写入
        writer << frametemp;
        writer_roi << frametemp_roi;
        boost::this_thread::sleep(boost::posix_time::milliseconds(
                100));  ///休眠8ms,所以不会记录完整的视频，因为抓图线程是休眠1ms,应该够用了，节约系统资源
    }
    //关上视频文件
    if (writer.isOpened()) {
        writer.release();
    }
    if (writer_roi.isOpened()) {
        writer_roi.release();
    }
    std::cout << "saveVideoLoop end" << std::endl;
}

/**
```

#### ` cv::VideoWriter`

cv::VideoWriter对象的创建有两种方式，第一种是使用构造函数的形式，第二种使用open()的方式，具体如下：


	cv::VideoWriter out(
		const string& filename, // 输入文件名
		int fourcc, // 编码形式，使用 CV_FOURCC()宏
		double fps, // 输出视频帧率
		cv::Size frame_size, // 单帧图片的大小
		bool is_color = true // 如果是false,可传入灰度图像 
	);
	
	cv::VideoWriter out;
	out.open(
		"my_video.mpg", //输出文件名
		CV_FOURCC('D','I','V','X'), // MPEG-4 编码
		30.0, // 帧率 (FPS)
		cv::Size( 640, 480 ), // 单帧图片分辨率为 640x480
		true // 只输入彩色图
	);

同样，向创建后的cv::VideoWriter对象写入图像也有两种方式，即write()操作和“<<”操作：

	cv::VideoWriter::write(
		const Mat& image // 写入图像作为下一帧
	);
	
	my_video_writer << my_frame;



#### `void mainTaskCallBack()`

```cpp
/**
 * @brief 主任务回调函数
 * @param timeStamp 
 * @param frameImage 
 */
void MainTask::mainTaskCallBack(
        const hitcrt::camera::TimePoint &timeStamp,
        const cv::Mat &frameImage) {
    boost::this_thread::interruption_point(); // FIXME
    if (!param::APROCESS.load(boost::memory_order_acquire) || frameImage.empty()) { // wait for cam close or error
        return;
    }
    {
        boost::shared_lock<boost::shared_mutex> readLock(param::communicateMutex);
        //Frame m_frame,Frame.h
        m_frame.set(frameImage, (double) timeStamp.time_since_epoch().count() * 1e-6 - param::BASE_TIME,param::s_comData);      
    }
    m_frame.m_comData.ROBOT_PITCH = degree2rad(m_frame.m_comData.ROBOT_PITCH);
    m_frame.m_comData.ROBOT_YAW = degree2rad(m_frame.m_comData.ROBOT_YAW);
    decodeBalance(m_frame.m_comData.BALANCE_NUM, m_frame.m_balanceNum);
    m_frame.m_comData.VELOCITY *= 1000.0; /// 使用mm/s

    std::vector<armorPlate> armors;         ///识别到的装甲板
    std::vector<armorPlate> armors_xtluse;  ///使用全局轨迹匹配到的装甲板

    m_detectMethPtr->runArmorDetect(m_frame, m_roiToolPtr->getMRect(), m_roiToolPtr->getMRoiOrigin(), armors);
    armors_xtluse.assign(armors.begin(), armors.end());
    m_assioMethPtr->runArmorAssociate(armors, false, m_goalId, m_frame.m_comData.CX_FLAG);
    m_assioMethXtlPtr->runArmorAssociate(armors, true, m_xtlGoalId, m_frame.m_comData.CX_FLAG);
    judgeIfFound();
    
    //全局视野
    if (param::GLOBAL_DETECT) {
        getGlobalResult();
    }

    if (m_IFFOUND == TARGET_FOUND || m_IFFOUND == TARGET_FIRST_FOUND) {
//        std::cout << "+++++++++++++++++++++++++++++++" << std::endl;
//        std::cout << m_armorFind.m_absolute_pw << std::endl;
//        std::cout << m_armorFind.m_abs_distance << std::endl;
//        std::cout << rad2degree(m_armorFind.m_calc_yaw) << std::endl;
//        std::cout << rad2degree(m_armorFind.m_calc_pitch) << std::endl;
//        std::cout << "+++++++++++++++++++++++++++++++" << std::endl;
        //判断目标状态
        judgeState();
        //保存滤波数据
        saveData();
        //ROI优化
        m_roiToolPtr->setROI(m_armorFind.m_center, m_armorFind.m_armorWidth, m_armorFind.m_armorHeight);
        // 有效的找到的装甲板
        m_lastArmor = m_armorFind;
        m_lastArmorXtl = m_armorFindXtl;
        //设置与电控通信的向量
        if (param::GLOBAL_DETECT && m_upGoal.getMAttackValue() > m_goalAttackValue &&
            m_upGoal.getMNumber() != m_goalNumber) {
            //切换
            sendData(SWITCH);
        } else {
            //目标
            sendData(AIM);
        }
    } else {
        if (param::GLOBAL_DETECT && m_upGoal.getMAttackValue() > 0) {
            sendData(SWITCH);
        } else {
            //巡逻
            sendData(PATROL);
        }
    }

    m_IFLASTFOUND = m_IFFOUND;
    m_frameTime = m_frame.m_time - m_lastFrame.m_time;
    m_lastFrame = m_frame;
    m_roiToolPtr->updateROI();

    if (param::DISPLAY || param::SAVE_VIDEO) {  ///显示图像
        showImage(armors);
    }
    m_mainTaskCallBackWatcherPtr->check(timeStamp);
    param::FPS_CALLBACK = m_mainTaskCallBackWatcherPtr->getMAverageFps();
    if (param::VERBOSE_MAINTASK) {
        ///开启用于测量帧率
        std::cout << "MainTask Fps: " << m_mainTaskCallBackWatcherPtr->getMAverageFps() << " F/S"<< std::endl;
    }
}

```

#### 帧处理

把相机抓取的每一帧都进行相应的收集，

```cpp
 {
        boost::shared_lock<boost::shared_mutex> readLock(param::communicateMutex);
        //Frame m_frame,Frame.h
        m_frame.set(frameImage, (double) timeStamp.time_since_epoch().count() * 1e-6 - param::BASE_TIME,param::s_comData);      
    }
    m_frame.m_comData.ROBOT_PITCH = degree2rad(m_frame.m_comData.ROBOT_PITCH);
    m_frame.m_comData.ROBOT_YAW = degree2rad(m_frame.m_comData.ROBOT_YAW);
    decodeBalance(m_frame.m_comData.BALANCE_NUM, m_frame.m_balanceNum);
    m_frame.m_comData.VELOCITY *= 1000.0; /// 使用mm/s

```



#### 目标算法

通过生成的帧的信息，对相应的需要信息进行处理，进行装甲板检测`m_detectMethPtr->runArmorDetect`，轨迹匹配`m_assioMethPtr->runArmorAssociate`

```cpp
std::vector<armorPlate> armors;         ///识别到的装甲板
    std::vector<armorPlate> armors_xtluse;  ///使用全局轨迹匹配到的装甲板

    m_detectMethPtr->runArmorDetect(m_frame, m_roiToolPtr->getMRect(), m_roiToolPtr->getMRoiOrigin(), armors);
    armors_xtluse.assign(armors.begin(), armors.end());
    m_assioMethPtr->runArmorAssociate(armors, false, m_goalId, m_frame.m_comData.CX_FLAG);
    m_assioMethXtlPtr->runArmorAssociate(armors, true, m_xtlGoalId, m_frame.m_comData.CX_FLAG);
 judgeIfFound();
```



#### 全局视野

```cpp
  //全局视野
    if (param::GLOBAL_DETECT) {
        getGlobalResult();
    }
```



















