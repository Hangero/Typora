```
# cmake needs this line
cmake_minimum_required(VERSION 2.8)
 
# Define project name
project(opencvTest)
 
# Find OpenCV, you may need to set OpenCV_DIR variable
# to the absolute path to the directory containing OpenCVConfig.cmake file
# via the command line or GUI
find_package(OpenCV REQUIRED)
 
# If the package has been found, several variables will
# be set, you can find the full list with descriptions
# in the OpenCVConfig.cmake file.
# Print some message showing some of them
message(STATUS "OpenCV library status:")
message(STATUS "    version: ${OpenCV_VERSION}")
message(STATUS "    libraries: ${OpenCV_LIBS}")
message(STATUS "    include path: ${OpenCV_INCLUDE_DIRS}")
 
# Add OpenCV headers location to your include paths
include_directories(${OpenCV_INCLUDE_DIRS})
 
# Declare the executable target built from your sources
add_executable(main main.cpp)
 
# Link your application with OpenCV libraries
target_link_libraries(main ${OpenCV_LIBS})

```



```
Mat img, img1,img2;
addSaltNoise(img,img1,300);//添加椒盐噪声
addGaussianNoise(img,img2,0,1);//添加高斯噪声（均值=0，方差=1）

```

```
//生成随机椒盐噪声
void addSaltNoise(const Mat &srcImage, Mat &dstImage, int n)
{
	dstImage = srcImage.clone();
	for (int k = 0; k < n; k++)
	{
		//随机取值行列
		int i = rand() % dstImage.rows;
		int j = rand() % dstImage.cols;
		//图像通道判定
		if (dstImage.channels() == 1)
		{
			dstImage.at<uchar>(i, j) = 255;		//盐噪声
		}
		else
		{
			dstImage.at<Vec3b>(i, j)[0] = 255;
			dstImage.at<Vec3b>(i, j)[1] = 255;
			dstImage.at<Vec3b>(i, j)[2] = 255;
		}
	}
	for (int k = 0; k < n; k++)
	{
		//随机取值行列
		int i = rand() % dstImage.rows;
		int j = rand() % dstImage.cols;
		//图像通道判定
		if (dstImage.channels() == 1)
		{
			dstImage.at<uchar>(i, j) = 0;		//椒噪声
		}
		else
		{
			dstImage.at<Vec3b>(i, j)[0] = 0;
			dstImage.at<Vec3b>(i, j)[1] = 0;
			dstImage.at<Vec3b>(i, j)[2] = 0;
		}
	}
}
//生成高斯噪声
double generateGaussianNoise(double mu, double sigma)
{
	//定义小值
	const double epsilon = numeric_limits<double>::min();
	static double z0, z1;
	static bool flag = false;
	flag = !flag;
	//flag为假构造高斯随机变量X
	if (!flag)
		return z1 * sigma + mu;
	double u1, u2;
	//构造随机变量
	do
	{
		u1 = rand() * (1.0 / RAND_MAX);
		u2 = rand() * (1.0 / RAND_MAX);
	} while (u1 <= epsilon);
	//flag为真构造高斯随机变量
	z0 = sqrt(-2.0*log(u1))*cos(2 * CV_PI*u2);
	z1 = sqrt(-2.0*log(u1))*sin(2 * CV_PI*u2);
	return z0*sigma + mu;
}
//为图像加入高斯噪声
void addGaussianNoise(Mat &srcImag, Mat &dstImage, double mu, double sigma)
{
	dstImage = srcImag.clone();
	int channels = dstImage.channels();
	int rowsNumber = dstImage.rows;
	int colsNumber = dstImage.cols*channels;
	//推断图像的连续性
	if (dstImage.isContinuous())
	{
		colsNumber *= rowsNumber;
		rowsNumber = 1;
	}
	for (int i = 0; i < rowsNumber; i++)
	{
		for (int j = 0; j < colsNumber; j++)
		{
			//加入高斯噪声
			int val = dstImage.ptr<uchar>(i)[j] +
				generateGaussianNoise(mu, sigma) * 32;
			if (val < 0)
				val = 0;
			if (val>255)
				val = 255;
			dstImage.ptr<uchar>(i)[j] = (uchar)val;
		}
	}
}


```

```cpp
#include <opencv/highgui.h>

#include <iostream>
#include <opencv2/imgcodecs.hpp>
#include <opencv2/imgproc.hpp>
#include <opencv2/opencv.hpp>

cv::Mat imgGray, imgBlur, imgCanny, imgDil, imgErode;

void getContours(cv::Mat imgDil, cv::Mat img) {
    std::vector<std::vector<cv::Point>> contours;
    std::vector<cv::Vec4i> hierarchy;

    cv::findContours(imgDil, contours, hierarchy, cv::RETR_EXTERNAL, cv::CHAIN_APPROX_SIMPLE);
    // cv::drawContours(img, contours, -1, cv::Scalar(255, 0, 255), 2);

    for (int i = 0; i < contours.size(); i++) {
        int area = cv::contourArea(contours[i]);
        std::cout << area << std::endl;
        if (area > 1000) {
            cv::drawContours(img, contours, -1, cv::Scalar(255, 0, 255), 2);
        }
    }
}

int main() {
    std::string path = "Resources/shapes.png";
    cv::Mat img = cv::imread(path);

    // Preprocessing
    cvtColor(img, imgGray, cv::COLOR_BGR2GRAY);
    GaussianBlur(imgGray, imgBlur, cv::Size(3, 3), 3, 0);
    Canny(imgBlur, imgCanny, 25, 75);
    cv::Mat kernel = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(3, 3));
    dilate(imgCanny, imgDil, kernel);
    getContours(imgDil, img);

    imshow("Image", img);
    /*  imshow("Image Gray", imgGray);
     imshow("Image Blur", imgBlur);
     imshow("Image Canny", imgCanny);
     imshow("Image Dil", imgDil); */
    cv::waitKey(0);

    cv::Rect roi(200, 100, 300, 300);
}

```

```
#include <iostream>
 
#define IMAGE_WIDTH 1920
#define IMAGE_HEIGHT 1080
 
int LimitValue(int val)
{
	if (val < 0)
		val = 0;
	else if (val > 255)
		val = 255;
 
	return val;
}
 
int main()
{
	FILE* fp = fopen("D:/test/4.yuv", "rb");
 
	if (NULL == fp)
	{
		printf("Can not open image file!\n");
		return -1;
	}
 
	fseek(fp, 0, SEEK_END);
	int len = ftell(fp);
	fseek(fp, 0, SEEK_SET);
 
	unsigned char* inputImage = new unsigned char[len]();
	unsigned char* outputImage = new unsigned char[len]();
	fread(inputImage, 1, len, fp);
	fclose(fp);
 
	memcpy(outputImage, inputImage, len);
 
	for (int i = 1; i < IMAGE_HEIGHT - 1; i++)
	{
		for (int j = 1; j < IMAGE_WIDTH - 1; j++)
		{
			unsigned char imageKernel[9] = { 0 };
			imageKernel[0] = inputImage[(i - 1)*IMAGE_WIDTH + j - 1];
			imageKernel[1] = inputImage[(i - 1)*IMAGE_WIDTH + j];
			imageKernel[2] = inputImage[(i - 1)*IMAGE_WIDTH + j + 1];
			imageKernel[3] = inputImage[(i)*IMAGE_WIDTH + j - 1];
			imageKernel[4] = inputImage[(i)*IMAGE_WIDTH + j];
			imageKernel[5] = inputImage[(i)*IMAGE_WIDTH + j + 1];
			imageKernel[6] = inputImage[(i + 1)*IMAGE_WIDTH + j - 1];
			imageKernel[7] = inputImage[(i + 1)*IMAGE_WIDTH + j];
			imageKernel[8] = inputImage[(i + 1)*IMAGE_WIDTH + j + 1];
 
			//化简后结果   这里使用了 1,1.414,1 的模板（各向同性Sobel算子），与 1,2,1的模板区别不是很大
			float GX = imageKernel[2] - imageKernel[0] + (imageKernel[5] - imageKernel[3]) * 1.414 + imageKernel[8] - imageKernel[6];
			float GY = imageKernel[0] + imageKernel[2] + (imageKernel[1] - imageKernel[7]) * 1.414 - imageKernel[6] - imageKernel[8];
 
			int val = LimitValue(sqrt(GX*GX + GY*GY) + 0.5);
 
			outputImage[i*IMAGE_WIDTH + j] = val;
		}
	}
 
	fp = fopen("D:/test/out.yuv", "wb+");
	fwrite(outputImage, 1, len, fp);
	fclose(fp);
 
	delete[] inputImage;
	delete[] outputImage;
 
	return 0;
}
```

```cpp
    /* //添加高斯噪声和椒盐噪声，显示并保存图像
    cv::Mat imgGaussianNoise, imgSaltNoise;

    addGaussianNoise(img, imgGaussianNoise, 3, 3);
    addSaltNoise(img, imgSaltNoise, 3000);

    cv::imshow("ImageGaussianNoise", imgGaussianNoise);
    cv::imshow("ImageSaltNoise", imgSaltNoise);

    cv::imwrite("ImageGaussianNoise.png", imgGaussianNoise);
    cv::imwrite("ImageSaltNoise.png", imgSaltNoise);

    //用均值滤波和中值滤波分别对高斯噪声和椒盐噪声图像进行平滑处理
    //显示并保存图像
    cv::Mat imgMeanFilter, imgMediumFilter;

    MeanFilter(imgGaussianNoise, imgMeanFilter);
    MediumFilter(imgSaltNoise, imgMediumFilter);

    cv::imshow("imgMeanFilter", imgMeanFilter);
    cv::imshow("imgMediumFilter", imgMediumFilter);

    cv::imwrite("imgMeanFilter.png", imgMeanFilter);
    cv::imwrite("imgMediumFilter.png", imgMediumFilter); */

    //灰度化
    cv::Mat imgGray;
    cv::cvtColor(img, imgGray, cv::COLOR_BGR2GRAY);
    cv::imshow("imgGray", imgGray);
    cv::imwrite("imgGray.png", imgGray);

    /* //边缘检测
    cv::Mat imgSobel;
    Sobel(imgGray, imgSobel);
    cv::imshow("imgSobe", imgSobel);
    cv::imwrite("imgSobel.png", imgSobel); */

    //直方图
    cv::Mat imgcalcGrayHist;
    calcGrayHist(img, imgcalcGrayHist);
    cv::imshow("imgcalcGrayHist", imgcalcGrayHist);
    cv::imwrite("imgcalcGrayHist.png", imgcalcGrayHist);

    //直方均衡化
    cv::Mat imgEqualizeHist;
    EqualizeHist(imgGray, imgEqualizeHist);
    cv::imshow("imgEqualizeHist", imgEqualizeHist);
    cv::imwrite("imgEqualizeHist.png", imgEqualizeHist);

    //直方均衡化后直方图
    cv::Mat imgEH_calcGrayHist;
    calcGrayHist(imgEqualizeHist, imgEH_calcGrayHist);
    cv::imshow("imgEH_calcGrayHist", imgEH_calcGrayHist);
    cv::imwrite("imgEH_calcGrayHist.png", imgEH_calcGrayHist);

    //同态滤波
    cv::Mat imgHomo;
    HomoFilter(imgGray, imgHomo);
    cv::imshow(" imgHomo", imgHomo);
```

```
{
			"type": "cmake",
			"label": "CMake: build",
			"command": "build",
			"targets": [
				"all"
			],
			"group": "build",
			"problemMatcher": [],
			"detail": "CMake template build task"
		}
```

```
4 绘制矩形边框

第一步，找出外边界
cnts = cv2.findContours(inRange_hsv.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)[-2]
使用该函数找出方框外边界，并存储在cnts中。
findContours 参考资料

第二步，找出矩形
在边界中找出面积最大的区域，选定该区域为方块所在区域，并绘制出该区域的最小外接矩形，并记录该矩形的位置坐标。
c = max(cnts, key=cv2.contourArea) 在边界中找出面积最大的区域
rect = cv2.minAreaRect(c) 绘制出该区域的最小外接矩形
box = cv2.boxPoints(rect) 记录该矩形四个点的位置坐标

第三步，绘制矩形
在原图像上将分析出的矩形边界绘制出来
cv2.drawContours(frame, [np.int0(box)], -1, (0, 255, 255), 2)
参数一：frame目标图像
参数二：[np.int0(box)]轮廓本身，在Python中是一个list
参数三：-1指定绘制轮廓list中的哪条轮廓，如果是-1，则绘制其中的所有轮廓。
参数四：(0, 255, 255)轮廓颜色BGR
参数五：2廓线的宽度
```

